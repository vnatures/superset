"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[117],{1334:(t,e,n)=>{n.d(e,{V:()=>b});var s=n(77117);function i(t,e,n){return t.createFramebuffer({width:e,height:n,colorAttachments:[t.createTexture({width:e,height:n,format:"rgba32float",mipmaps:!1,sampler:{minFilter:"nearest",magFilter:"nearest"}})]})}const r={name:"binSorter",vs:"uniform binSorterUniforms {\n  ivec4 binIdRange;\n  ivec2 targetSize;\n} binSorter;\n",uniformTypes:{binIdRange:"vec4<i32>",targetSize:"vec2<i32>"}},o=[1,2,4,8],a=3e38,l={SUM:0,MEAN:0,MIN:0,MAX:0,COUNT:0},u=1024;class d{constructor(t,e){this.binsFBO=null,this.device=t,this.model=function(t,e){let n=e.vs;2===e.dimensions&&(n+="\nvoid getBin(out int binId) {\n  ivec2 binId2;\n  getBin(binId2);\n  if (binId2.x < binSorter.binIdRange.x || binId2.x >= binSorter.binIdRange.y) {\n    binId = -1;\n  } else {\n    binId = (binId2.y - binSorter.binIdRange.z) * (binSorter.binIdRange.y - binSorter.binIdRange.x) + binId2.x;\n  }\n}\n");const i=`#version 300 es\n#define SHADER_NAME gpu-aggregation-sort-bins-vertex\n\n${n}\n\nout vec3 v_Value;\n\nvoid main() {\n  int binIndex;\n  getBin(binIndex);\n  binIndex = binIndex - binSorter.binIdRange.x;\n  if (binIndex < 0) {\n    gl_Position = vec4(0.);\n    return;\n  }\n  int row = binIndex / binSorter.targetSize.x;\n  int col = binIndex - row * binSorter.targetSize.x;\n  vec2 position = (vec2(col, row) + 0.5) / vec2(binSorter.targetSize) * 2.0 - 1.0;\n  gl_Position = vec4(position, 0.0, 1.0);\n  gl_PointSize = 1.0;\n\n#if NUM_CHANNELS == 3\n  getValue(v_Value);\n#elif NUM_CHANNELS == 2\n  getValue(v_Value.xy);\n#else\n  getValue(v_Value.x);\n#endif\n}\n`;return new s.K(t,{bufferLayout:e.bufferLayout,modules:[...e.modules||[],r],defines:{...e.defines,NON_INSTANCED_MODEL:1,NUM_CHANNELS:e.channelCount},isInstanced:!1,vs:i,fs:"#version 300 es\n#define SHADER_NAME gpu-aggregation-sort-bins-fragment\n\nprecision highp float;\n\nin vec3 v_Value;\nout vec4 fragColor;\n\nvoid main() {\n  fragColor.xyz = v_Value;\n\n  #ifdef MODULE_GEOMETRY\n  geometry.uv = vec2(0.);\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n  #endif\n\n  fragColor.w = 1.0;\n}\n",topology:"point-list",disableWarnings:!0})}(t,e)}get texture(){return this.binsFBO?this.binsFBO.colorAttachments[0].texture:null}destroy(){this.model.destroy(),this.binsFBO?.colorAttachments[0].texture.destroy(),this.binsFBO?.destroy()}getBinValues(t){if(!this.binsFBO)return null;const e=t%u,n=Math.floor(t/u),s=this.device.readPixelsToArrayWebGL(this.binsFBO,{sourceX:e,sourceY:n,sourceWidth:1,sourceHeight:1}).buffer;return new Float32Array(s)}setDimensions(t,e){const n=u,s=Math.ceil(t/n);this.binsFBO?this.binsFBO.height<s&&this.binsFBO.resize({width:n,height:s}):this.binsFBO=i(this.device,n,s);const r={binIdRange:[e[0][0],e[0][1],e[1]?.[0]||0,e[1]?.[1]||0],targetSize:[this.binsFBO.width,this.binsFBO.height]};this.model.shaderInputs.setProps({binSorter:r})}setModelProps(t){const e=this.model;t.attributes&&e.setAttributes(t.attributes),t.constantAttributes&&e.setConstantAttributes(t.constantAttributes),void 0!==t.vertexCount&&e.setVertexCount(t.vertexCount),t.shaderModuleProps&&e.shaderInputs.setProps(t.shaderModuleProps)}update(t){if(!this.binsFBO)return;const e=function(t){const e={...l};for(let n=0;n<t.length;n++){const s=t[n];s&&(e[s]+=o[n])}return e}(t);this._updateBins("SUM",e.SUM+e.MEAN),this._updateBins("MIN",e.MIN),this._updateBins("MAX",e.MAX)}_updateBins(t,e){if(0===e)return;e|=o[3];const n=this.model,s=this.binsFBO,i="MAX"===t?-a:"MIN"===t?a:0,r=this.device.beginRenderPass({id:`gpu-aggregation-${t}`,framebuffer:s,parameters:{viewport:[0,0,s.width,s.height],colorMask:e},clearColor:[i,i,i,0],clearDepth:!1,clearStencil:!1});n.setParameters({blend:!0,blendColorSrcFactor:"one",blendColorDstFactor:"one",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one",blendColorOperation:"MAX"===t?"max":"MIN"===t?"min":"add",blendAlphaOperation:"add"}),n.draw(r),r.end()}}var h=n(93362);const g={name:"aggregatorTransform",vs:"uniform aggregatorTransformUniforms {\n  ivec4 binIdRange;\n  bvec3 isCount;\n  bvec3 isMean;\n  float naN;\n} aggregatorTransform;\n",uniformTypes:{binIdRange:"vec4<i32>",isCount:"vec3<f32>",isMean:"vec3<f32>"}};class f{constructor(t,e){this.binBuffer=null,this.valueBuffer=null,this._domains=null,this.device=t,this.channelCount=e.channelCount,this.transform=function(t,e){return new h.p(t,{vs:"#version 300 es\n#define SHADER_NAME gpu-aggregation-domain-vertex\n\nuniform sampler2D bins;\n\n#if NUM_DIMS == 1\nout float binIds;\n#else\nout vec2 binIds;\n#endif\n\n#if NUM_CHANNELS == 1\nflat out float values;\n#elif NUM_CHANNELS == 2\nflat out vec2 values;\n#else\nflat out vec3 values;\n#endif\n\nconst float NAN = intBitsToFloat(-1);\n\nvoid main() {\n  int row = gl_VertexID / SAMPLER_WIDTH;\n  int col = gl_VertexID - row * SAMPLER_WIDTH;\n  vec4 weights = texelFetch(bins, ivec2(col, row), 0);\n  vec3 value3 = mix(\n    mix(weights.rgb, vec3(weights.a), aggregatorTransform.isCount),\n    weights.rgb / max(weights.a, 1.0),\n    aggregatorTransform.isMean\n  );\n  if (weights.a == 0.0) {\n    value3 = vec3(NAN);\n  }\n\n#if NUM_DIMS == 1\n  binIds = float(gl_VertexID + aggregatorTransform.binIdRange.x);\n#else\n  int y = gl_VertexID / (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);\n  int x = gl_VertexID - y * (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);\n  binIds.y = float(y + aggregatorTransform.binIdRange.z);\n  binIds.x = float(x + aggregatorTransform.binIdRange.x);\n#endif\n\n#if NUM_CHANNELS == 3\n  values = value3;\n#elif NUM_CHANNELS == 2\n  values = value3.xy;\n#else\n  values = value3.x;\n#endif\n\n  gl_Position = vec4(0., 0., 0., 1.);\n  // This model renders into a 2x1 texture to obtain min and max simultaneously.\n  // See comments in fragment shader\n  gl_PointSize = 2.0;\n}\n",fs:"#version 300 es\n#define SHADER_NAME gpu-aggregation-domain-fragment\n\nprecision highp float;\n\n#if NUM_CHANNELS == 1\nflat in float values;\n#elif NUM_CHANNELS == 2\nflat in vec2 values;\n#else\nflat in vec3 values;\n#endif\n\nout vec4 fragColor;\n\nvoid main() {\n  vec3 value3;\n#if NUM_CHANNELS == 3\n  value3 = values;\n#elif NUM_CHANNELS == 2\n  value3.xy = values;\n#else\n  value3.x = values;\n#endif\n  if (isnan(value3.x)) discard;\n  // This shader renders into a 2x1 texture with blending=max\n  // The left pixel yields the max value of each channel\n  // The right pixel yields the min value of each channel\n  if (gl_FragCoord.x < 1.0) {\n    fragColor = vec4(value3, 1.0);\n  } else {\n    fragColor = vec4(-value3, 1.0);\n  }\n}\n",topology:"point-list",modules:[g],parameters:{blend:!0,blendColorSrcFactor:"one",blendColorDstFactor:"one",blendColorOperation:"max",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one",blendAlphaOperation:"max"},defines:{NUM_DIMS:e.dimensions,NUM_CHANNELS:e.channelCount,SAMPLER_WIDTH:u},varyings:["binIds","values"],disableWarnings:!0})}(t,e),this.domainFBO=i(t,2,1)}destroy(){this.transform.destroy(),this.binBuffer?.destroy(),this.valueBuffer?.destroy(),this.domainFBO.colorAttachments[0].texture.destroy(),this.domainFBO.destroy()}get domains(){if(!this._domains){const t=this.device.readPixelsToArrayWebGL(this.domainFBO).buffer,e=new Float32Array(t);this._domains=[[-e[4],e[0]],[-e[5],e[1]],[-e[6],e[2]]].slice(0,this.channelCount)}return this._domains}setDimensions(t,e){const{model:n,transformFeedback:s}=this.transform;n.setVertexCount(t);const i={binIdRange:[e[0][0],e[0][1],e[1]?.[0]||0,e[1]?.[1]||0]};n.shaderInputs.setProps({aggregatorTransform:i});const r=t*e.length*4;(!this.binBuffer||this.binBuffer.byteLength<r)&&(this.binBuffer?.destroy(),this.binBuffer=this.device.createBuffer({byteLength:r}),s.setBuffer("binIds",this.binBuffer));const o=t*this.channelCount*4;(!this.valueBuffer||this.valueBuffer.byteLength<o)&&(this.valueBuffer?.destroy(),this.valueBuffer=this.device.createBuffer({byteLength:o}),s.setBuffer("values",this.valueBuffer))}update(t,e){if(!t)return;const n=this.transform,s=this.domainFBO,i={isCount:[0,1,2].map((t=>"COUNT"===e[t]?1:0)),isMean:[0,1,2].map((t=>"MEAN"===e[t]?1:0)),bins:t};n.model.shaderInputs.setProps({aggregatorTransform:i}),n.run({id:"gpu-aggregation-domain",framebuffer:s,parameters:{viewport:[0,0,2,1]},clearColor:[-3e38,-3e38,-3e38,0],clearDepth:!1,clearStencil:!1}),this._domains=null}}var c=n(20688),p=n(18277);class b{static isSupported(t){return t.features.has("float32-renderable-webgl")&&t.features.has("texture-blend-float-webgl")}constructor(t,e){this.binCount=0,this.binIds=null,this.results=[],this.device=t,this.dimensions=e.dimensions,this.channelCount=e.channelCount,this.props={...e,pointCount:0,binIdRange:[[0,0]],operations:[],attributes:{},binOptions:{}},this.needsUpdate=new Array(this.channelCount).fill(!0),this.binSorter=new d(t,e),this.aggregationTransform=new f(t,e),this.setProps(e)}getBins(){const t=this.aggregationTransform.binBuffer;return t?(this.binIds?.buffer!==t&&(this.binIds={buffer:t,type:"float32",size:this.dimensions}),this.binIds):null}getResult(t){const e=this.aggregationTransform.valueBuffer;return!e||t>=this.channelCount?null:(this.results[t]?.buffer!==e&&(this.results[t]={buffer:e,type:"float32",size:1,stride:4*this.channelCount,offset:4*t}),this.results[t])}getResultDomain(t){return this.aggregationTransform.domains[t]}getBin(t){if(t<0||t>=this.binCount)return null;const{binIdRange:e}=this.props;let n;if(1===this.dimensions)n=[t+e[0][0]];else{const[[s,i],[r]]=e,o=i-s;n=[t%o+s,Math.floor(t/o)+r]}const s=this.binSorter.getBinValues(t);if(!s)return null;const i=s[3],r=[];for(let t=0;t<this.channelCount;t++){const e=this.props.operations[t];r[t]="COUNT"===e?i:0===i?NaN:"MEAN"===e?s[t]/i:s[t]}return{id:n,value:r,count:i}}destroy(){this.binSorter.destroy(),this.aggregationTransform.destroy()}setProps(t){const e=this.props;if("binIdRange"in t&&!(0,c.b)(t.binIdRange,e.binIdRange,2)){const e=t.binIdRange;if(p.A.assert(e.length===this.dimensions),1===this.dimensions){const[[t,n]]=e;this.binCount=n-t}else{const[[t,n],[s,i]]=e;this.binCount=(n-t)*(i-s)}this.binSorter.setDimensions(this.binCount,e),this.aggregationTransform.setDimensions(this.binCount,e),this.setNeedsUpdate()}if(t.operations)for(let n=0;n<this.channelCount;n++)t.operations[n]!==e.operations[n]&&this.setNeedsUpdate(n);if(void 0!==t.pointCount&&t.pointCount!==e.pointCount&&(this.binSorter.setModelProps({vertexCount:t.pointCount}),this.setNeedsUpdate()),t.binOptions&&((0,c.b)(t.binOptions,e.binOptions,2)||this.setNeedsUpdate(),this.binSorter.model.shaderInputs.setProps({binOptions:t.binOptions})),t.attributes){const e={},n={};for(const s of Object.values(t.attributes))for(const[t,i]of Object.entries(s.getValue()))ArrayBuffer.isView(i)?n[t]=i:i&&(e[t]=i);this.binSorter.setModelProps({attributes:e,constantAttributes:n})}t.shaderModuleProps&&this.binSorter.setModelProps({shaderModuleProps:t.shaderModuleProps}),Object.assign(this.props,t)}setNeedsUpdate(t){void 0===t?this.needsUpdate.fill(!0):this.needsUpdate[t]=!0}update(){}preDraw(){if(!this.needsUpdate.some(Boolean))return;const{operations:t}=this.props,e=this.needsUpdate.map(((e,n)=>e?t[n]:null));this.binSorter.update(e),this.aggregationTransform.update(this.binSorter.texture,t);for(let t=0;t<this.channelCount;t++)this.needsUpdate[t]&&(this.needsUpdate[t]=!1,this.props.onUpdate?.({channel:t}))}}},12965:(t,e,n)=>{n.d(e,{A:()=>o});var s=n(84402),i=n(89503);class r extends s.A{get isDrawable(){return!0}initializeState(){this.getAttributeManager().remove(["instancePickingColors"])}updateState(t){super.updateState(t);const e=this.getAggregatorType();if(t.changeFlags.extensionsChanged||this.state.aggregatorType!==e){this.state.aggregator?.destroy();const t=this.createAggregator(e);return t.setProps({attributes:this.getAttributeManager()?.attributes}),this.setState({aggregator:t,aggregatorType:e}),!0}return!1}finalizeState(t){super.finalizeState(t),this.state.aggregator.destroy()}updateAttributes(t){const{aggregator:e}=this.state;e.setProps({attributes:t});for(const e in t)this.onAttributeChange(e);e.update()}draw({shaderModuleProps:t}){const{aggregator:e}=this.state;e.setProps({shaderModuleProps:t}),e.preDraw()}_getAttributeManager(){return new i.A(this.context.device,{id:this.props.id,stats:this.context.stats})}}r.layerName="AggregationLayer";const o=r},48928:(t,e,n)=>{n.d(e,{M:()=>u});var s=n(20688);const i=(t,e)=>{let n=0;for(const s of t)n+=e(s);return n},r={COUNT:t=>t.length,SUM:i,MEAN:(t,e)=>0===t.length?NaN:i(t,e)/t.length,MIN:(t,e)=>{let n=1/0;for(const s of t){const t=e(s);t<n&&(n=t)}return n},MAX:(t,e)=>{let n=-1/0;for(const s of t){const t=e(s);t>n&&(n=t)}return n}};function o({bins:t,getValue:e,operation:n,target:s}){(!s||s.length<t.length)&&(s=new Float32Array(t.length));let i=1/0,r=-1/0;for(let o=0;o<t.length;o++){const{points:a}=t[o];s[o]=n(a,e),s[o]<i&&(i=s[o]),s[o]>r&&(r=s[o])}return{value:s,domain:[i,r]}}function a(t,e,n){const s={};for(const n of t.sources||[]){const t=e[n];if(!t)throw new Error(`Cannot find attribute ${n}`);s[n]=l(t)}const i={};return e=>{for(const t in s)i[t]=s[t](e);return t.getValue(i,e,n)}}function l(t){const e=t.value,{offset:n=0,stride:s,size:i}=t.getAccessor(),r=e.BYTES_PER_ELEMENT,o=n/r,a=s?s/r:i;if(1===i)return t.isConstant?()=>e[0]:t=>e[o+a*t];let l;return t.isConstant?(l=Array.from(e),()=>l):(l=new Array(i),t=>{const n=o+a*t;for(let t=0;t<i;t++)l[t]=e[n+t];return l})}class u{constructor(t){this.bins=[],this.binIds=null,this.results=[],this.dimensions=t.dimensions,this.channelCount=t.getValue.length,this.props={...t,binOptions:{},pointCount:0,operations:[],customOperations:[],attributes:{}},this.needsUpdate=!0,this.setProps(t)}destroy(){}get binCount(){return this.bins.length}setProps(t){const e=this.props;if(t.binOptions&&((0,s.b)(t.binOptions,e.binOptions,2)||this.setNeedsUpdate()),t.operations)for(let n=0;n<this.channelCount;n++)t.operations[n]!==e.operations[n]&&this.setNeedsUpdate(n);if(t.customOperations)for(let n=0;n<this.channelCount;n++)Boolean(t.customOperations[n])!==Boolean(e.customOperations[n])&&this.setNeedsUpdate(n);void 0!==t.pointCount&&t.pointCount!==e.pointCount&&this.setNeedsUpdate(),t.attributes&&(t.attributes={...e.attributes,...t.attributes}),Object.assign(this.props,t)}setNeedsUpdate(t){void 0===t?this.needsUpdate=!0:!0!==this.needsUpdate&&(this.needsUpdate=this.needsUpdate||[],this.needsUpdate[t]=!0)}update(){if(!0===this.needsUpdate){this.bins=function({pointCount:t,getBinId:e}){const n=new Map;for(let s=0;s<t;s++){const t=e(s);if(null===t)continue;let i=n.get(String(t));i?i.points.push(s):(i={id:t,index:n.size,points:[s]},n.set(String(t),i))}return Array.from(n.values())}({pointCount:this.props.pointCount,getBinId:a(this.props.getBin,this.props.attributes,this.props.binOptions)});const t=function({bins:t,dimensions:e,target:n}){const s=t.length*e;(!n||n.length<s)&&(n=new Float32Array(s));for(let s=0;s<t.length;s++){const{id:i}=t[s];Array.isArray(i)?n.set(i,s*e):n[s]=i}return n}({bins:this.bins,dimensions:this.dimensions,target:this.binIds?.value});this.binIds={value:t,type:"float32",size:this.dimensions}}for(let t=0;t<this.channelCount;t++)if(!0===this.needsUpdate||this.needsUpdate[t]){const e=this.props.customOperations[t]||r[this.props.operations[t]],{value:n,domain:s}=o({bins:this.bins,getValue:a(this.props.getValue[t],this.props.attributes,void 0),operation:e,target:this.results[t]?.value});this.results[t]={value:n,domain:s,type:"float32",size:1},this.props.onUpdate?.({channel:t})}this.needsUpdate=!1}preDraw(){}getBins(){return this.binIds}getResult(t){return this.results[t]}getResultDomain(t){return this.results[t]?.domain??[1/0,-1/0]}getBin(t){const e=this.bins[t];if(!e)return null;const n=new Array(this.channelCount);for(let e=0;e<n.length;e++){const s=this.results[e];n[e]=s?.value[t]}return{id:e.id,value:n,count:e.points.length,pointIndices:e.points}}}}}]);