"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[1937],{23197:(i,e,t)=>{t.d(e,{A:()=>o});const n={props:{},uniforms:{},name:"picking",uniformTypes:{isActive:"f32",isAttribute:"f32",isHighlightActive:"f32",useFloatColors:"f32",highlightedObjectColor:"vec3<f32>",highlightColor:"vec4<f32>"},defaultUniforms:{isActive:!1,isAttribute:!1,isHighlightActive:!1,useFloatColors:!0,highlightedObjectColor:[0,0,0],highlightColor:[0,1,1,1]},vs:"uniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nout vec4 picking_vRGBcolor_Avalid;\n\n// Normalize unsigned byte color to 0-1 range\nvec3 picking_normalizeColor(vec3 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\n// Normalize unsigned byte color to 0-1 range\nvec4 picking_normalizeColor(vec4 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\nbool picking_isColorZero(vec3 color) {\n  return dot(color, vec3(1.0)) < 0.00001;\n}\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.00001;\n}\n\n// Check if this vertex is highlighted \nbool isVertexHighlighted(vec3 vertexColor) {\n  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\n  return\n    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\n\n// Set the current picking color\nvoid picking_setPickingColor(vec3 pickingColor) {\n  pickingColor = picking_normalizeColor(pickingColor);\n\n  if (bool(picking.isActive)) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!bool(picking.isAttribute)) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec2 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec3 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n",fs:"uniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (picking.isActive > 0.5) {\n    return color;\n  }\n\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    // Blend in highlight color based on its alpha value\n    float highLightAlpha = picking.highlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highlightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highlightColor);\n}\n",getUniforms:function(i={},e){const t={};if(void 0===i.highlightedObjectColor);else if(null===i.highlightedObjectColor)t.isHighlightActive=!1;else{t.isHighlightActive=!0;const e=i.highlightedObjectColor.slice(0,3);t.highlightedObjectColor=e}if(i.highlightColor){const e=Array.from(i.highlightColor,(i=>i/255));Number.isFinite(e[3])||(e[3]=1),t.highlightColor=e}return void 0!==i.isActive&&(t.isActive=Boolean(i.isActive),t.isAttribute=Boolean(i.isAttribute)),void 0!==i.useFloatColors&&(t.useFloatColors=Boolean(i.useFloatColors)),t}},o={...n,defaultUniforms:{...n.defaultUniforms,useFloatColors:!1},inject:{"vs:DECKGL_FILTER_GL_POSITION":"\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  ","vs:DECKGL_FILTER_COLOR":"\n  picking_setPickingColor(geometry.pickingColor);\n  ","fs:DECKGL_FILTER_COLOR":{order:99,injection:"\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    "}}}},33549:(i,e,t)=>{t.d(e,{A:()=>p});var n=t(75077),o=t(82101),l=t(23197),s=t(16704),r=t(83391),a=t(77117);const c="uniform scatterplotUniforms {\n  float radiusScale;\n  float radiusMinPixels;\n  float radiusMaxPixels;\n  float lineWidthScale;\n  float lineWidthMinPixels;\n  float lineWidthMaxPixels;\n  float stroked;\n  bool filled;\n  bool antialiasing;\n  bool billboard;\n  highp int radiusUnits;\n  highp int lineWidthUnits;\n} scatterplot;\n",d={name:"scatterplot",vs:c,fs:c,uniformTypes:{radiusScale:"f32",radiusMinPixels:"f32",radiusMaxPixels:"f32",lineWidthScale:"f32",lineWidthMinPixels:"f32",lineWidthMaxPixels:"f32",stroked:"f32",filled:"f32",antialiasing:"f32",billboard:"f32",radiusUnits:"i32",lineWidthUnits:"i32"}},g=[0,0,0,255],u={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,billboard:!1,antialiasing:!0,getPosition:{type:"accessor",value:i=>i.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:g},getLineColor:{type:"accessor",value:g},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class h extends n.A{getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME scatterplot-layer-vertex-shader\nin vec3 positions;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin float instanceRadius;\nin float instanceLineWidths;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin vec3 instancePickingColors;\nout vec4 vFillColor;\nout vec4 vLineColor;\nout vec2 unitPosition;\nout float innerUnitRadius;\nout float outerRadiusPixels;\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\nouterRadiusPixels = clamp(\nproject_size_to_pixel(scatterplot.radiusScale * instanceRadius, scatterplot.radiusUnits),\nscatterplot.radiusMinPixels, scatterplot.radiusMaxPixels\n);\nfloat lineWidthPixels = clamp(\nproject_size_to_pixel(scatterplot.lineWidthScale * instanceLineWidths, scatterplot.lineWidthUnits),\nscatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels\n);\nouterRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;\nfloat edgePadding = scatterplot.antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\nunitPosition = edgePadding * positions.xy;\ngeometry.uv = unitPosition;\ngeometry.pickingColor = instancePickingColors;\ninnerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / outerRadiusPixels;\nif (scatterplot.billboard) {\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvec3 offset = edgePadding * positions * outerRadiusPixels;\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n} else {\nvec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n}\nvFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vFillColor, geometry);\nvLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME scatterplot-layer-fragment-shader\nprecision highp float;\nin vec4 vFillColor;\nin vec4 vLineColor;\nin vec2 unitPosition;\nin float innerUnitRadius;\nin float outerRadiusPixels;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = unitPosition;\nfloat distToCenter = length(unitPosition) * outerRadiusPixels;\nfloat inCircle = scatterplot.antialiasing ?\nsmoothedge(distToCenter, outerRadiusPixels) :\nstep(distToCenter, outerRadiusPixels);\nif (inCircle == 0.0) {\ndiscard;\n}\nif (scatterplot.stroked > 0.5) {\nfloat isLine = scatterplot.antialiasing ?\nsmoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\nstep(innerUnitRadius * outerRadiusPixels, distToCenter);\nif (scatterplot.filled) {\nfragColor = mix(vFillColor, vLineColor, isLine);\n} else {\nif (isLine == 0.0) {\ndiscard;\n}\nfragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n}\n} else if (scatterplot.filled == false) {\ndiscard;\n} else {\nfragColor = vFillColor;\n}\nfragColor.a *= inCircle;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:[o.A,l.A,d]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,type:"unorm8",accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,type:"unorm8",accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(i){super.updateState(i),i.changeFlags.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:i}){const{radiusUnits:e,radiusScale:t,radiusMinPixels:n,radiusMaxPixels:o,stroked:l,filled:r,billboard:a,antialiasing:c,lineWidthUnits:d,lineWidthScale:g,lineWidthMinPixels:u,lineWidthMaxPixels:h}=this.props,p={stroked:l,filled:r,billboard:a,antialiasing:c,radiusUnits:s.p5[e],radiusScale:t,radiusMinPixels:n,radiusMaxPixels:o,lineWidthUnits:s.p5[d],lineWidthScale:g,lineWidthMinPixels:u,lineWidthMaxPixels:h},v=this.state.model;v.shaderInputs.setProps({scatterplot:p}),v.draw(this.context.renderPass)}_getModel(){return new a.K(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new r.V({topology:"triangle-strip",attributes:{positions:{size:3,value:new Float32Array([-1,-1,0,1,-1,0,-1,1,0,1,1,0])}}}),isInstanced:!0})}}h.defaultProps=u,h.layerName="ScatterplotLayer";const p=h},41937:(i,e,t)=>{t.r(e),t.d(e,{default:()=>h,getLayer:()=>u});var n=t(33549),o=t(36770),l=t(95579),s=t(41857),r=t(47823),a=t(32548);const c=1609.34;var d=t(2445);function g(i,e){return t=>{var n,s,r,c,g,u,h,p,v;const f=(null==e?void 0:e[i.point_radius_fixed.value])||(0,o.A)(null==(n=i.point_radius_fixed)?void 0:n.value);return(0,d.FD)("div",{className:"deckgl-tooltip",children:[(0,d.Y)(a.A,{label:(0,l.t)("Longitude and Latitude")+": ",value:`${null==(s=t.object)||null==(r=s.position)?void 0:r[0]}, ${null==(c=t.object)||null==(g=c.position)?void 0:g[1]}`}),(null==(u=t.object)?void 0:u.cat_color)&&(0,d.Y)(a.A,{label:(0,l.t)("Category")+": ",value:`${null==(h=t.object)?void 0:h.cat_color}`}),(null==(p=t.object)?void 0:p.metric)&&(0,d.Y)(a.A,{label:`${f}: `,value:`${null==(v=t.object)?void 0:v.metric}`})]})}}function u(i,e,t,o,l){const r=i,a=e.data.features.map((i=>{let e=(t=r.point_unit,n=i.radius,("square_m"===t?Math.sqrt(n/Math.PI):"radius_m"===t?n:"radius_km"===t?1e3*n:"radius_miles"===t?n*c:"square_km"===t?1e3*Math.sqrt(n/Math.PI):"square_miles"===t?Math.sqrt(n/Math.PI)*c:null)||10);var t,n;if(r.multiplier&&(e*=r.multiplier),i.color)return{...i,radius:e};const o=r.color_picker||{r:0,g:0,b:0,a:1},l=[o.r,o.g,o.b,255*o.a];return{...i,radius:e,color:l}}));return new n.A({id:`scatter-layer-${r.slice_id}`,data:a,fp64:!0,getFillColor:i=>i.color,getRadius:i=>i.radius,radiusMinPixels:Number(r.min_radius)||void 0,radiusMaxPixels:Number(r.max_radius)||void 0,stroked:!1,...(0,s.T)(r,o,g(r,null==l?void 0:l.verboseMap))})}const h=(0,r.c)(u,(function(i){return i.map((i=>i.position))}))},83391:(i,e,t)=>{t.d(e,{V:()=>o});var n=t(48910);class o{id;topology;vertexCount;indices;attributes;userData={};constructor(i){const{attributes:e={},indices:t=null,vertexCount:o=null}=i;this.id=i.id||(0,n.L)("geometry"),this.topology=i.topology,t&&(this.indices=ArrayBuffer.isView(t)?{value:t,size:1}:t),this.attributes={};for(const[i,t]of Object.entries(e)){const e=ArrayBuffer.isView(t)?{value:t}:t;if(!ArrayBuffer.isView(e.value))throw new Error(`${this._print(i)}: must be typed array or object with value as typed array`);if("POSITION"!==i&&"positions"!==i||e.size||(e.size=3),"indices"===i){if(this.indices)throw new Error("Multiple indices detected");this.indices=e}else this.attributes[i]=e}this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this.vertexCount=o||this._calculateVertexCount(this.attributes,this.indices)}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(i){return`Geometry ${this.id} attribute ${i}`}_setAttributes(i,e){return this}_calculateVertexCount(i,e){if(e)return e.value.length;let t=1/0;for(const e of Object.values(i)){const{value:i,size:n,constant:o}=e;!o&&i&&void 0!==n&&n>=1&&(t=Math.min(t,i.length/n))}return t}}}}]);