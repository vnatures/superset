"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[4325],{22986:(i,t,n)=>{n.d(t,{J:()=>r});var e=n(27915),o=n(55248);const r={props:{},name:"gouraudMaterial",vs:o.l.replace("phongMaterial","gouraudMaterial"),fs:o.X.replace("phongMaterial","gouraudMaterial"),defines:{LIGHTING_VERTEX:1},dependencies:[e.x],uniformTypes:{ambient:"f32",diffuse:"f32",shininess:"f32",specularColor:"vec3<f32>"},defaultUniforms:{ambient:.35,diffuse:.6,shininess:32,specularColor:[.15,.15,.15]},getUniforms(i){const t={...i};return t.specularColor&&(t.specularColor=t.specularColor.map((i=>i/255))),{...r.defaultUniforms,...t}}}},27915:(i,t,n)=>{n.d(t,{x:()=>l});var e=n(39749);const o="precision highp int;\n\n// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\n  vec3 color;\n};\n\nstruct PointLight {\n  vec3 color;\n  vec3 position;\n  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform lightingUniforms {\n  int enabled;\n  int lightType;\n\n  int directionalLightCount;\n  int pointLightCount;\n\n  vec3 ambientColor;\n\n  vec3 lightColor0;\n  vec3 lightPosition0;\n  vec3 lightDirection0;\n  vec3 lightAttenuation0;\n\n  vec3 lightColor1;\n  vec3 lightPosition1;\n  vec3 lightDirection1;\n  vec3 lightAttenuation1;\n\n  vec3 lightColor2;\n  vec3 lightPosition2;\n  vec3 lightDirection2;\n  vec3 lightAttenuation2;\n} lighting;\n\nPointLight lighting_getPointLight(int index) {\n  switch (index) {\n    case 0:\n      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);\n    case 1:\n      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);\n    case 2:\n    default:  \n      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);\n  }\n}\n\nDirectionalLight lighting_getDirectionalLight(int index) {\n  switch (index) {\n    case 0:\n      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);\n    case 1:\n      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);\n    case 2:\n    default:   \n      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);\n  }\n} \n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n// #endif\n";var r;!function(i){i[i.POINT=0]="POINT",i[i.DIRECTIONAL=1]="DIRECTIONAL"}(r||(r={}));const l={props:{},uniforms:{},name:"lighting",defines:{MAX_LIGHTS:3},uniformTypes:{enabled:"i32",lightType:"i32",directionalLightCount:"i32",pointLightCount:"i32",ambientLightColor:"vec3<f32>",lightColor0:"vec3<f32>",lightPosition0:"vec3<f32>",lightDirection0:"vec3<f32>",lightAttenuation0:"vec3<f32>",lightColor1:"vec3<f32>",lightPosition1:"vec3<f32>",lightDirection1:"vec3<f32>",lightAttenuation1:"vec3<f32>",lightColor2:"vec3<f32>",lightPosition2:"vec3<f32>",lightDirection2:"vec3<f32>",lightAttenuation2:"vec3<f32>"},defaultUniforms:{enabled:1,lightType:r.POINT,directionalLightCount:0,pointLightCount:0,ambientLightColor:[.1,.1,.1],lightColor0:[1,1,1],lightPosition0:[1,1,2],lightDirection0:[1,1,1],lightAttenuation0:[1,0,0],lightColor1:[1,1,1],lightPosition1:[1,1,2],lightDirection1:[1,1,1],lightAttenuation1:[1,0,0],lightColor2:[1,1,1],lightPosition2:[1,1,2],lightDirection2:[1,1,1],lightAttenuation2:[1,0,0]},source:"// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\n  color: vec3<f32>,\n};\n\nstruct PointLight {\n  color: vec3<f32>,\n  position: vec3<f32>,\n  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential\n};\n\nstruct DirectionalLight {\n  color: vec3<f32>,\n  direction: vec3<f32>,\n};\n\nstruct lightingUniforms {\n  enabled: i32,\n  poightCount: i32,\n  directionalLightCount: i32,\n\n  ambientColor: vec3<f32>,\n\n  // TODO - support multiple lights by uncommenting arrays below\n  lightType: i32,\n  lightColor: vec3<f32>,\n  lightDirection: vec3<f32>,\n  lightPosition: vec3<f32>,\n  lightAttenuation: vec3<f32>,\n\n  // AmbientLight ambientLight;\n  // PointLight pointLight[MAX_LIGHTS];\n  // DirectionalLight directionalLight[MAX_LIGHTS];\n};\n\n// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)\n@binding(1) @group(0) var<uniform> lighting : lightingUniforms;\n\nfn lighting_getPointLight(index: i32) -> PointLight {\n  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);\n}\n\nfn lighting_getDirectionalLight(index: i32) -> DirectionalLight {\n  return DirectionalLight(lighting.lightColor, lighting.lightDirection);\n} \n\nfn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n",vs:o,fs:o,getUniforms:function(i,t={}){if(!(i=i?{...i}:i))return{...l.defaultUniforms};i.lights&&(i={...i,...a(i.lights),lights:void 0});const{ambientLight:n,pointLights:e,directionalLights:o}=i||{};if(!(n||e&&e.length>0||o&&o.length>0))return{...l.defaultUniforms,enabled:0};const r={...l.defaultUniforms,...t,...g({ambientLight:n,pointLights:e,directionalLights:o})};return void 0!==i.enabled&&(r.enabled=i.enabled?1:0),r}};function g({ambientLight:i,pointLights:t=[],directionalLights:n=[]}){const o={};o.ambientLightColor=s(i);let l=0;for(const i of t){o.lightType=r.POINT;const t=l;o[`lightColor${t}`]=s(i),o[`lightPosition${t}`]=i.position,o[`lightAttenuation${t}`]=i.attenuation||[1,0,0],l++}for(const i of n){o.lightType=r.DIRECTIONAL;const t=l;o[`lightColor${t}`]=s(i),o[`lightDirection${t}`]=i.direction,l++}return l>3&&e.R.warn("MAX_LIGHTS exceeded")(),o.directionalLightCount=n.length,o.pointLightCount=t.length,o}function a(i){const t={pointLights:[],directionalLights:[]};for(const n of i||[])switch(n.type){case"ambient":t.ambientLight=n;break;case"directional":t.directionalLights?.push(n);break;case"point":t.pointLights?.push(n)}return t}function s(i={}){const{color:t=[0,0,0],intensity:n=1}=i;return t.map((i=>i*n/255))}},55248:(i,t,n)=>{n.d(t,{X:()=>e,l:()=>o});const e="uniform phongMaterialUniforms {\n  uniform float ambient;\n  uniform float diffuse;\n  uniform float shininess;\n  uniform vec3  specularColor;\n} material;\n",o="uniform phongMaterialUniforms {\n  uniform float ambient;\n  uniform float diffuse;\n  uniform float shininess;\n  uniform vec3  specularColor;\n} material;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n  vec3 halfway_direction = normalize(light_direction + view_direction);\n  float lambertian = dot(light_direction, normal_worldspace);\n  float specular = 0.0;\n  if (lambertian > 0.0) {\n    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, material.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  vec3 view_direction = normalize(cameraPosition - position_worldspace);\n  lightColor = material.ambient * surfaceColor * lighting.ambientColor;\n\n  for (int i = 0; i < lighting.pointLightCount; i++) {\n    PointLight pointLight = lighting_getPointLight(i);\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);\n  }\n\n  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);\n  for (int i = lighting.pointLightCount; i < totalLights; i++) {\n    DirectionalLight directionalLight = lighting_getDirectionalLight(i);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n}\n"},84402:(i,t,n)=>{n.d(t,{A:()=>a});var e=n(75077),o=n(7277),r=n(95801),l=n(68427);class g extends e.A{get isComposite(){return!0}get isDrawable(){return!1}get isLoaded(){return super.isLoaded&&this.getSubLayers().every((i=>i.isLoaded))}getSubLayers(){return this.internalState&&this.internalState.subLayers||[]}initializeState(i){}setState(i){super.setState(i),this.setNeedsUpdate()}getPickingInfo({info:i}){const{object:t}=i;return t&&t.__source&&t.__source.parent&&t.__source.parent.id===this.id?(i.object=t.__source.object,i.index=t.__source.index,i):i}filterSubLayer(i){return!0}shouldRenderSubLayer(i,t){return t&&t.length}getSubLayerClass(i,t){const{_subLayerProps:n}=this.props;return n&&n[i]&&n[i].type||t}getSubLayerRow(i,t,n){return i.__source={parent:this,object:t,index:n},i}getSubLayerAccessor(i){if("function"==typeof i){const t={index:-1,data:this.props.data,target:[]};return(n,e)=>n&&n.__source?(t.index=n.__source.index,i(n.__source.object,t)):i(n,e)}return i}getSubLayerProps(i={}){const{opacity:t,pickable:n,visible:e,parameters:o,getPolygonOffset:r,highlightedObjectIndex:g,autoHighlight:a,highlightColor:s,coordinateSystem:h,coordinateOrigin:c,wrapLongitude:u,positionFormat:d,modelMatrix:p,extensions:f,fetch:L,operation:m,_subLayerProps:_}=this.props,v={id:"",updateTriggers:{},opacity:t,pickable:n,visible:e,parameters:o,getPolygonOffset:r,highlightedObjectIndex:g,autoHighlight:a,highlightColor:s,coordinateSystem:h,coordinateOrigin:c,wrapLongitude:u,positionFormat:d,modelMatrix:p,extensions:f,fetch:L,operation:m},b=_&&i.id&&_[i.id],C=b&&b.updateTriggers,y=i.id||"sublayer";if(b){const t=this.props[l.fW],n=i.type?i.type._propTypes:{};for(const i in b){const e=n[i]||t[i];e&&"accessor"===e.type&&(b[i]=this.getSubLayerAccessor(b[i]))}}Object.assign(v,i,b),v.id=`${this.props.id}-${y}`,v.updateTriggers={all:this.props.updateTriggers?.all,...i.updateTriggers,...C};for(const i of f){const t=i.getSubLayerProps.call(this,i);t&&Object.assign(v,t,{updateTriggers:Object.assign(v.updateTriggers,t.updateTriggers)})}return v}_updateAutoHighlight(i){for(const t of this.getSubLayers())t.updateAutoHighlight(i)}_getAttributeManager(){return null}_postUpdate(i,t){let n=this.internalState.subLayers;const e=!n||this.needsUpdate();if(e){const i=this.renderLayers();n=(0,r.B)(i,Boolean),this.internalState.subLayers=n}(0,o.A)("compositeLayer.renderLayers",this,e,n);for(const i of n)i.parent=this}}g.layerName="CompositeLayer";const a=g}}]);