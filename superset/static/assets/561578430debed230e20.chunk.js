"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[1052],{23197:(e,t,i)=>{i.d(t,{A:()=>n});const o={props:{},uniforms:{},name:"picking",uniformTypes:{isActive:"f32",isAttribute:"f32",isHighlightActive:"f32",useFloatColors:"f32",highlightedObjectColor:"vec3<f32>",highlightColor:"vec4<f32>"},defaultUniforms:{isActive:!1,isAttribute:!1,isHighlightActive:!1,useFloatColors:!0,highlightedObjectColor:[0,0,0],highlightColor:[0,1,1,1]},vs:"uniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nout vec4 picking_vRGBcolor_Avalid;\n\n// Normalize unsigned byte color to 0-1 range\nvec3 picking_normalizeColor(vec3 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\n// Normalize unsigned byte color to 0-1 range\nvec4 picking_normalizeColor(vec4 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\nbool picking_isColorZero(vec3 color) {\n  return dot(color, vec3(1.0)) < 0.00001;\n}\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.00001;\n}\n\n// Check if this vertex is highlighted \nbool isVertexHighlighted(vec3 vertexColor) {\n  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\n  return\n    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\n\n// Set the current picking color\nvoid picking_setPickingColor(vec3 pickingColor) {\n  pickingColor = picking_normalizeColor(pickingColor);\n\n  if (bool(picking.isActive)) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!bool(picking.isAttribute)) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec2 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec3 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n",fs:"uniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (picking.isActive > 0.5) {\n    return color;\n  }\n\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    // Blend in highlight color based on its alpha value\n    float highLightAlpha = picking.highlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highlightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highlightColor);\n}\n",getUniforms:function(e={},t){const i={};if(void 0===e.highlightedObjectColor);else if(null===e.highlightedObjectColor)i.isHighlightActive=!1;else{i.isHighlightActive=!0;const t=e.highlightedObjectColor.slice(0,3);i.highlightedObjectColor=t}if(e.highlightColor){const t=Array.from(e.highlightColor,(e=>e/255));Number.isFinite(t[3])||(t[3]=1),i.highlightColor=t}return void 0!==e.isActive&&(i.isActive=Boolean(e.isActive),i.isAttribute=Boolean(e.isAttribute)),void 0!==e.useFloatColors&&(i.useFloatColors=Boolean(e.useFloatColors)),i}},n={...o,defaultUniforms:{...o.defaultUniforms,useFloatColors:!1},inject:{"vs:DECKGL_FILTER_GL_POSITION":"\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  ","vs:DECKGL_FILTER_COLOR":"\n  picking_setPickingColor(geometry.pickingColor);\n  ","fs:DECKGL_FILTER_COLOR":{order:99,injection:"\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    "}}}},25564:(e,t,i)=>{i.d(t,{A:()=>c});var o=i(68961),n=i.n(o),r=i(4523),s=i(12619),a=i(49443);const l={console,_:r.Ay,colors:a,d3array:s};function c(e,t,i){const o={},r=`SAFE_EVAL_${Math.floor(1e6*Math.random())}`;o[r]={};const s=`${r}=${e}`,a={...l,...t};Object.keys(a).forEach((e=>{o[e]=a[e]}));try{return n().runInNewContext(s,o,i),o[r]}catch(e){return()=>e}}},32548:(e,t,i)=>{i.d(t,{A:()=>n});var o=i(2445);const n=({label:e,value:t})=>(0,o.FD)("div",{children:[e,(0,o.Y)("strong",{children:t})]})},41857:(e,t,i)=>{i.d(t,{T:()=>r,g:()=>l});var o=i(12619),n=i(25564);function r(e,t,i,o){const r=e;let s,a,l=i;return r.js_tooltip&&(l=(0,n.A)(r.js_tooltip)),l&&(s=e=>(e.picked?t({content:l(e),x:e.x,y:e.y}):t(null),!0)),r.js_onclick_href?a=e=>{const t=(0,n.A)(r.js_onclick_href)(e);return window.open(t),!0}:r.table_filter&&void 0!==o&&(a=e=>(o(e.object[r.line_column]),!0)),{onClick:a,onHover:s,pickable:Boolean(s)}}const s={p1:.01,p5:.05,p95:.95,p99:.99},a={sum:o.sum,min:o.min,max:o.max,mean:o.mean,median:o.median,variance:o.variance,deviation:o.deviation};function l(e="sum",t=null){if("count"===e)return e=>e.length;let i;if(e in s)i=(i,n)=>{let r;return r=t?i.sort(((e,i)=>(0,o.ascending)(t(e),t(i)))):i.sort(o.ascending),(0,o.quantile)(r,s[e],n)};else{if(!(e in a))throw new Error(`Unsupported aggregation type: ${e}`);i=a[e]}return t?e=>i(e.map((e=>t(e)))):e=>i(e)}},44147:(e,t,i)=>{i.r(t),i.d(t,{default:()=>R,getLayer:()=>P});var o=i(96540),n=i(82101),r=i(1334),s=i(48928),a=i(12965),l=i(77117),c=i(83391),g=i(75077),p=i(23197),h=i(83102);const d={name:"screenGrid",vs:"uniform screenGridUniforms {\n  vec2 cellSizeClipspace;\n  vec2 gridSizeClipspace;\n  vec2 colorDomain;\n} screenGrid;\n",uniformTypes:{cellSizeClipspace:"vec2<f32>",gridSizeClipspace:"vec2<f32>",colorDomain:"vec2<f32>"}};class u extends g.A{getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME screen-grid-layer-vertex-shader\n#define RANGE_COUNT 6\nin vec2 positions;\nin vec2 instancePositions;\nin float instanceWeights;\nin vec3 instancePickingColors;\nuniform sampler2D colorRange;\nout vec4 vColor;\nvec4 interp(float value, vec2 domain, sampler2D range) {\nfloat r = (value - domain.x) / (domain.y - domain.x);\nreturn texture(range, vec2(r, 0.5));\n}\nvoid main(void) {\nif (isnan(instanceWeights)) {\ngl_Position = vec4(0.);\nreturn;\n}\nvec2 pos = instancePositions * screenGrid.gridSizeClipspace + positions * screenGrid.cellSizeClipspace;\npos.x = pos.x - 1.0;\npos.y = 1.0 - pos.y;\ngl_Position = vec4(pos, 0., 1.);\nvColor = interp(instanceWeights, screenGrid.colorDomain, colorRange);\nvColor.a *= layer.opacity;\npicking_setPickingColor(instancePickingColors);\n}\n",fs:"#version 300 es\n#define SHADER_NAME screen-grid-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nout vec4 fragColor;\nvoid main(void) {\nfragColor = vColor;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:[p.A,d]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:2,type:"float32",accessor:"getBin"},instanceWeights:{size:1,type:"float32",accessor:"getWeight"}}),this.state.model=this._getModel()}updateState(e){super.updateState(e);const{props:t,oldProps:i,changeFlags:o}=e,n=this.state.model;if(i.colorRange!==t.colorRange){this.state.colorTexture?.destroy(),this.state.colorTexture=(0,h.cp)(this.context.device,t.colorRange,t.colorScaleType);const e={colorRange:this.state.colorTexture};n.shaderInputs.setProps({screenGrid:e})}else i.colorScaleType!==t.colorScaleType&&(0,h.Pu)(this.state.colorTexture,t.colorScaleType);if(i.cellMarginPixels!==t.cellMarginPixels||i.cellSizePixels!==t.cellSizePixels||o.viewportChanged){const{width:e,height:t}=this.context.viewport,{cellSizePixels:i,cellMarginPixels:o}=this.props,r=Math.max(i-o,0),s={gridSizeClipspace:[i/e*2,i/t*2],cellSizeClipspace:[r/e*2,r/t*2]};n.shaderInputs.setProps({screenGrid:s})}}finalizeState(e){super.finalizeState(e),this.state.colorTexture?.destroy()}draw({uniforms:e}){const t=this.props.colorDomain(),i=this.state.model,o={colorDomain:t};i.shaderInputs.setProps({screenGrid:o}),i.draw(this.context.renderPass)}_getModel(){return new l.K(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new c.V({topology:"triangle-strip",attributes:{positions:{value:new Float32Array([0,0,1,0,0,1,1,1]),size:2}}}),isInstanced:!0})}}u.layerName="ScreenGridCellLayer";const f=u,v={name:"binOptions",vs:"uniform binOptionsUniforms {\n  float cellSizePixels;\n} binOptions;\n",uniformTypes:{cellSizePixels:"f32"}},m={cellSizePixels:{type:"number",value:100,min:1},cellMarginPixels:{type:"number",value:2,min:0},colorRange:h.QO,colorScaleType:"linear",getPosition:{type:"accessor",value:e=>e.position},getWeight:{type:"accessor",value:1},gpuAggregation:!0,aggregation:"SUM"};class b extends a.A{getAggregatorType(){return this.props.gpuAggregation&&r.V.isSupported(this.context.device)?"gpu":"cpu"}createAggregator(e){return"cpu"!==e&&r.V.isSupported(this.context.device)?new r.V(this.context.device,{dimensions:2,channelCount:1,bufferLayout:this.getAttributeManager().getBufferLayouts({isInstanced:!1}),...super.getShaders({modules:[n.A,v],vs:"\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float counts;\n  \n  void getBin(out ivec2 binId) {\n    vec4 pos = project_position_to_clipspace(positions, positions64Low, vec3(0.0));\n    vec2 screenCoords = vec2(pos.x / pos.w + 1.0, 1.0 - pos.y / pos.w) / 2.0 * project.viewportSize / project.devicePixelRatio;\n    vec2 gridCoords = floor(screenCoords / binOptions.cellSizePixels);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out float weight) {\n    weight = counts;\n  }\n  "})}):new s.M({dimensions:2,getBin:{sources:["positions"],getValue:({positions:e},t,i)=>{const o=this.context.viewport,n=o.project(e),r=i.cellSizePixels;return n[0]<0||n[0]>=o.width||n[1]<0||n[1]>=o.height?null:[Math.floor(n[0]/r),Math.floor(n[1]/r)]}},getValue:[{sources:["counts"],getValue:({counts:e})=>e}]})}initializeState(){super.initializeState(),this.getAttributeManager().add({positions:{size:3,accessor:"getPosition",type:"float64",fp64:this.use64bitPositions()},counts:{size:1,accessor:"getWeight"}})}shouldUpdateState({changeFlags:e}){return e.somethingChanged}updateState(e){const t=super.updateState(e),{props:i,oldProps:o,changeFlags:n}=e,{cellSizePixels:s,aggregation:a}=i;if(t||n.dataChanged||n.updateTriggersChanged||n.viewportChanged||a!==o.aggregation||s!==o.cellSizePixels){const{width:e,height:t}=this.context.viewport,{aggregator:i}=this.state;i instanceof r.V&&i.setProps({binIdRange:[[0,Math.ceil(e/s)],[0,Math.ceil(t/s)]]}),i.setProps({pointCount:this.getNumInstances(),operations:[a],binOptions:{cellSizePixels:s}})}return n.viewportChanged&&this.state.aggregator.setNeedsUpdate(),t}onAttributeChange(e){const{aggregator:t}=this.state;switch(e){case"positions":t.setNeedsUpdate();break;case"counts":t.setNeedsUpdate(0)}}renderLayers(){const{aggregator:e}=this.state,t=this.getSubLayerClass("cells",f),i=e.getBins(),o=e.getResult(0);return new t(this.props,this.getSubLayerProps({id:"cell-layer"}),{data:{length:e.binCount,attributes:{getBin:i,getWeight:o}},dataComparator:(e,t)=>e.length===t.length,updateTriggers:{getBin:[i],getWeight:[o]},parameters:{depthWriteEnabled:!1,...this.props.parameters},colorDomain:()=>this.props.colorDomain||e.getResultDomain(0),extensions:[]})}getPickingInfo(e){const t=e.info,{index:i}=t;if(i>=0){const e=this.state.aggregator.getBin(i);let o;e&&(o={col:e.id[0],row:e.id[1],value:e.value[0],count:e.count},e.pointIndices&&(o.pointIndices=e.pointIndices,o.points=Array.isArray(this.props.data)?e.pointIndices.map((e=>this.props.data[e])):[])),t.object=o}return t}}b.layerName="ScreenGridLayer",b.defaultProps=m;const y=b;var C=i(95579),_=i(25564),k=i(41857),A=i(32548),x=i(95490),S=i(70957),w=i(2445);function L(e){var t,i,o;return(0,w.FD)("div",{className:"deckgl-tooltip",children:[(0,w.Y)(A.A,{label:(0,C.t)("Longitude and Latitude")+": ",value:`${null==e||null==(t=e.coordinate)?void 0:t[0]}, ${null==e||null==(i=e.coordinate)?void 0:i[1]}`}),(0,w.Y)(A.A,{label:(0,C.t)("Weight")+": ",value:`${null==(o=e.object)?void 0:o.cellWeight}`})]})}function P(e,t,i,o){const n=e,r=n.color_picker;let s=t.data.features.map((e=>({...e,color:[r.r,r.g,r.b,255*r.a]})));return n.js_data_mutator&&(s=(0,_.A)(n.js_data_mutator)(s)),new y({id:`screengrid-layer-${n.slice_id}`,data:s,cellSizePixels:n.grid_size,minColor:[r.r,r.g,r.b,0],maxColor:[r.r,r.g,r.b,255*r.a],outline:!1,getWeight:e=>e.weight||0,...(0,k.T)(n,o,L)})}const z=e=>{const t=(0,o.useRef)(),i=(0,o.useCallback)((()=>{const t=e.payload.data.features||[],{width:i,height:o,formData:n}=e;return n.autozoom?(0,x.A)(e.viewport,{width:i,height:o,points:(r=t,r.map((e=>e.position)))}):e.viewport;var r}),[e]),[n,r]=(0,o.useState)(e.payload.form_data),[s,a]=(0,o.useState)(i());(0,o.useEffect)((()=>{e.payload.form_data!==n&&(a(i()),r(e.payload.form_data))}),[i,e.payload.form_data,n]);const l=(0,o.useCallback)((e=>{const{current:i}=t;i&&i.setTooltip(e)}),[]),c=(0,o.useCallback)((()=>[P(e.formData,e.payload,0,l)]),[e.formData,e.payload,l]),{formData:g,payload:p,setControlValue:h}=e;return(0,w.Y)("div",{children:(0,w.Y)(S.S,{ref:t,viewport:s,layers:c(),setControlValue:h,mapStyle:g.mapbox_style,mapboxApiAccessToken:p.data.mapboxApiKey,width:e.width,height:e.height})})},R=(0,o.memo)(z)},49443:(e,t,i)=>{i.r(t),i.d(t,{hexToRGB:()=>n});var o=i(2117);function n(e,t=255){if(!e)return[0,0,0,t];const{r:i,g:n,b:r}=(0,o.Qh)(e);return[i,n,r,t]}},70957:(e,t,i)=>{i.d(t,{S:()=>f});var o=i(2404),n=i.n(o),r=i(96540),s=i(88813),a=i(82487),l=i(83505),c=i(96453),g=i(58642),p=i(2445);const h=c.I4.div`
  ${({theme:e,top:t,left:i})=>`\n    position: absolute;\n    top: ${t}px;\n    left: ${i}px;\n    padding: ${2*e.gridUnit}px;\n    margin: ${2*e.gridUnit}px;\n    background: ${e.colors.grayscale.dark2};\n    color: ${e.colors.grayscale.light5};\n    maxWidth: 300px;\n    fontSize: ${e.typography.sizes.s}px;\n    zIndex: 9;\n    pointerEvents: none;\n  `}
`;function d(e){const{tooltip:t}=e;if(null==t)return null;const{x:i,y:o,content:n}=t,r="string"==typeof n?(0,g.nn)(n):n;return(0,p.Y)(h,{top:o,left:i,children:r})}const u=(0,r.memo)((0,r.forwardRef)(((e,t)=>{const[i,o]=(0,r.useState)(null),[c,g]=(0,r.useState)(null),[h,u]=(0,r.useState)(e.viewport),f=(0,l.Z)(e.viewport);(0,r.useImperativeHandle)(t,(()=>({setTooltip:o})),[]);const v=(0,r.useCallback)((()=>{if(c&&Date.now()-c>250){const t=e.setControlValue;t&&t("viewport",h),g(null)}}),[c,e.setControlValue,h]);(0,r.useEffect)((()=>{const e=setInterval(v,250);return clearInterval(e)}),[v]),(0,r.useEffect)((()=>{n()(e.viewport,f)||u(e.viewport)}),[f,e.viewport]);const m=(0,r.useCallback)((({viewState:e})=>{u(e),g(Date.now())}),[]),b=(0,r.useCallback)((()=>e.layers.some((e=>"function"==typeof e))?e.layers.map((e=>"function"==typeof e?e():e)):e.layers),[e.layers]),{children:y=null,height:C,width:_}=e;return(0,p.FD)(p.FK,{children:[(0,p.FD)("div",{style:{position:"relative",width:_,height:C},children:[(0,p.Y)(a.A,{controller:!0,width:_,height:C,layers:b(),viewState:h,onViewStateChange:m,children:(0,p.Y)(s.b,{preserveDrawingBuffer:!0,mapStyle:e.mapStyle||"light",mapboxApiAccessToken:e.mapboxApiAccessToken})}),y]}),(0,p.Y)(d,{tooltip:i})]})}))),f=(0,c.I4)(u)`
  .deckgl-tooltip > div {
    overflow: hidden;
    text-overflow: ellipsis;
  }
`},83102:(e,t,i)=>{i.d(t,{Pu:()=>s,QO:()=>o,Y5:()=>n,cp:()=>a});const o=[[255,255,178],[254,217,118],[254,178,76],[253,141,60],[240,59,32],[189,0,38]];function n(e,t=!1,i=Float32Array){let o;if(Number.isFinite(e[0]))o=new i(e);else{o=new i(4*e.length);let t=0;for(let i=0;i<e.length;i++){const n=e[i];o[t++]=n[0],o[t++]=n[1],o[t++]=n[2],o[t++]=Number.isFinite(n[3])?n[3]:255}}if(t)for(let e=0;e<o.length;e++)o[e]/=255;return o}const r={linear:"linear",quantile:"nearest",quantize:"nearest",ordinal:"nearest"};function s(e,t){e.setSampler({minFilter:r[t],magFilter:r[t]})}function a(e,t,i="linear"){const o=n(t,!1,Uint8Array);return e.createTexture({format:"rgba8unorm",mipmaps:!1,sampler:{minFilter:r[i],magFilter:r[i],addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"},data:o,width:o.length/4,height:1})}},83391:(e,t,i)=>{i.d(t,{V:()=>n});var o=i(48910);class n{id;topology;vertexCount;indices;attributes;userData={};constructor(e){const{attributes:t={},indices:i=null,vertexCount:n=null}=e;this.id=e.id||(0,o.L)("geometry"),this.topology=e.topology,i&&(this.indices=ArrayBuffer.isView(i)?{value:i,size:1}:i),this.attributes={};for(const[e,i]of Object.entries(t)){const t=ArrayBuffer.isView(i)?{value:i}:i;if(!ArrayBuffer.isView(t.value))throw new Error(`${this._print(e)}: must be typed array or object with value as typed array`);if("POSITION"!==e&&"positions"!==e||t.size||(t.size=3),"indices"===e){if(this.indices)throw new Error("Multiple indices detected");this.indices=t}else this.attributes[e]=t}this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this.vertexCount=n||this._calculateVertexCount(this.attributes,this.indices)}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(e){return`Geometry ${this.id} attribute ${e}`}_setAttributes(e,t){return this}_calculateVertexCount(e,t){if(t)return t.value.length;let i=1/0;for(const t of Object.values(e)){const{value:e,size:o,constant:n}=t;!n&&e&&void 0!==o&&o>=1&&(i=Math.min(i,e.length/o))}return i}}},83505:(e,t,i)=>{i.d(t,{Z:()=>n});var o=i(96540);function n(e,t){const i=(0,o.useRef)(t);return(0,o.useEffect)((()=>{i.current=e}),[e]),i.current}},84402:(e,t,i)=>{i.d(t,{A:()=>l});var o=i(75077),n=i(7277),r=i(95801),s=i(68427);class a extends o.A{get isComposite(){return!0}get isDrawable(){return!1}get isLoaded(){return super.isLoaded&&this.getSubLayers().every((e=>e.isLoaded))}getSubLayers(){return this.internalState&&this.internalState.subLayers||[]}initializeState(e){}setState(e){super.setState(e),this.setNeedsUpdate()}getPickingInfo({info:e}){const{object:t}=e;return t&&t.__source&&t.__source.parent&&t.__source.parent.id===this.id?(e.object=t.__source.object,e.index=t.__source.index,e):e}filterSubLayer(e){return!0}shouldRenderSubLayer(e,t){return t&&t.length}getSubLayerClass(e,t){const{_subLayerProps:i}=this.props;return i&&i[e]&&i[e].type||t}getSubLayerRow(e,t,i){return e.__source={parent:this,object:t,index:i},e}getSubLayerAccessor(e){if("function"==typeof e){const t={index:-1,data:this.props.data,target:[]};return(i,o)=>i&&i.__source?(t.index=i.__source.index,e(i.__source.object,t)):e(i,o)}return e}getSubLayerProps(e={}){const{opacity:t,pickable:i,visible:o,parameters:n,getPolygonOffset:r,highlightedObjectIndex:a,autoHighlight:l,highlightColor:c,coordinateSystem:g,coordinateOrigin:p,wrapLongitude:h,positionFormat:d,modelMatrix:u,extensions:f,fetch:v,operation:m,_subLayerProps:b}=this.props,y={id:"",updateTriggers:{},opacity:t,pickable:i,visible:o,parameters:n,getPolygonOffset:r,highlightedObjectIndex:a,autoHighlight:l,highlightColor:c,coordinateSystem:g,coordinateOrigin:p,wrapLongitude:h,positionFormat:d,modelMatrix:u,extensions:f,fetch:v,operation:m},C=b&&e.id&&b[e.id],_=C&&C.updateTriggers,k=e.id||"sublayer";if(C){const t=this.props[s.fW],i=e.type?e.type._propTypes:{};for(const e in C){const o=i[e]||t[e];o&&"accessor"===o.type&&(C[e]=this.getSubLayerAccessor(C[e]))}}Object.assign(y,e,C),y.id=`${this.props.id}-${k}`,y.updateTriggers={all:this.props.updateTriggers?.all,...e.updateTriggers,..._};for(const e of f){const t=e.getSubLayerProps.call(this,e);t&&Object.assign(y,t,{updateTriggers:Object.assign(y.updateTriggers,t.updateTriggers)})}return y}_updateAutoHighlight(e){for(const t of this.getSubLayers())t.updateAutoHighlight(e)}_getAttributeManager(){return null}_postUpdate(e,t){let i=this.internalState.subLayers;const o=!i||this.needsUpdate();if(o){const e=this.renderLayers();i=(0,r.B)(e,Boolean),this.internalState.subLayers=i}(0,n.A)("compositeLayer.renderLayers",this,o,i);for(const e of i)e.parent=this}}a.layerName="CompositeLayer";const l=a},95490:(e,t,i)=>{i.d(t,{A:()=>l});var o=i(55016),n=i(12619);const r=[-90,90],s=[-180,180];function a([e,t],[i,o],n=.25){return e<t?[e,t]:[Math.max(i,e-n),Math.min(o,t+n)]}function l(e,{points:t,width:i,height:l,minExtent:c,maxZoom:g,offset:p,padding:h=20}){const{bearing:d,pitch:u}=e,f=function(e){const t=a((0,n.extent)(e,(e=>e[1])),r),i=a((0,n.extent)(e,(e=>e[0])),s);return[[i[0],t[0]],[i[1],t[1]]]}(t);try{return{...(0,o.Fe)({bounds:f,width:i,height:l,minExtent:c,maxZoom:g,offset:p,padding:h}),bearing:d,pitch:u}}catch(e){console.error("Could not fit viewport",e)}return e}}}]);