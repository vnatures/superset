"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[3206],{83206:(e,t,o)=>{o.d(t,{A:()=>R});var n=o(18277),i=o(82101),a=o(81729),r=o(35775),s=o(1334),l=o(48928),c=o(12965),g=o(83102),u=o(4359),p=o(34460),d=o(10951);const m=Math.PI/3,v=2*Math.sin(m),h=Array.from({length:6},((e,t)=>{const o=t*m;return[Math.sin(o),-Math.cos(o)]}));function C([e,t],o){let n=Math.round(t=t/o/1.5),i=Math.round(e=e/o/v-(1&n)/2);const a=t-n;if(3*Math.abs(a)>1){const o=e-i,r=i+(e<i?-1:1)/2,s=n+(t<n?-1:1),l=e-r,c=t-s;o*o+a*a>l*l+c*c&&(i=r+(1&n?1:-1)/2,n=s)}return[i,n]}const f=`\nconst vec2 DIST = vec2(${v}, 1.5);\n\nivec2 pointToHexbin(vec2 p, float radius) {\n  p /= radius * DIST;\n  float pj = round(p.y);\n  float pjm2 = mod(pj, 2.0);\n  p.x -= pjm2 * 0.5;\n  float pi = round(p.x);\n  vec2 d1 = p - vec2(pi, pj);\n\n  if (abs(d1.y) * 3. > 1.) {\n    vec2 v2 = step(0.0, d1) - 0.5;\n    v2.y *= 2.0;\n    vec2 d2 = d1 - v2;\n    if (dot(d1, d1) > dot(d2, d2)) {\n      pi += v2.x + pjm2 - 0.5;\n      pj += v2.y;\n    }\n  }\n  return ivec2(pi, pj);\n}\n`;function x([e,t],o){return[(e+(1&t)/2)*o*v,t*o*1.5]}const y=`#version 300 es\n#define SHADER_NAME hexagon-cell-layer-vertex-shader\nin vec3 positions;\nin vec3 normals;\nin vec2 instancePositions;\nin float instanceElevationValues;\nin float instanceColorValues;\nin vec3 instancePickingColors;\nuniform sampler2D colorRange;\nout vec4 vColor;\n\nconst vec2 DIST = vec2(${v}, 1.5);\n\nvec2 hexbinCentroid(vec2 binId, float radius) {\n  binId.x += fract(binId.y * 0.5);\n  return binId * DIST * radius;\n}\n\nfloat interp(float value, vec2 domain, vec2 range) {\nfloat r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);\nreturn mix(range.x, range.y, r);\n}\nvec4 interp(float value, vec2 domain, sampler2D range) {\nfloat r = (value - domain.x) / (domain.y - domain.x);\nreturn texture(range, vec2(r, 0.5));\n}\nvoid main(void) {\ngeometry.pickingColor = instancePickingColors;\nif (isnan(instanceColorValues) ||\ninstanceColorValues < hexagon.colorDomain.z ||\ninstanceColorValues > hexagon.colorDomain.w ||\ninstanceElevationValues < hexagon.elevationDomain.z ||\ninstanceElevationValues > hexagon.elevationDomain.w\n) {\ngl_Position = vec4(0.);\nreturn;\n}\nvec2 commonPosition = hexbinCentroid(instancePositions, column.radius) + (hexagon.originCommon - project.commonOrigin.xy);\ncommonPosition += positions.xy * column.radius * column.coverage;\ngeometry.position = vec4(commonPosition, 0.0, 1.0);\ngeometry.normal = project_normal(normals);\nfloat elevation = 0.0;\nif (column.extruded) {\nelevation = interp(instanceElevationValues, hexagon.elevationDomain.xy, hexagon.elevationRange);\nelevation = project_size(elevation);\ngeometry.position.z = (positions.z + 1.0) / 2.0 * elevation;\n}\ngl_Position = project_common_position_to_clipspace(geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvColor = interp(instanceColorValues, hexagon.colorDomain.xy, colorRange);\nvColor.a *= layer.opacity;\nif (column.extruded) {\nvColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\n}\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n`,b={name:"hexagon",vs:"uniform hexagonUniforms {\n  vec4 colorDomain;\n  vec4 elevationDomain;\n  vec2 elevationRange;\n  vec2 originCommon;\n} hexagon;\n",uniformTypes:{colorDomain:"vec4<f32>",elevationDomain:"vec4<f32>",elevationRange:"vec2<f32>",originCommon:"vec2<f32>"}};class P extends d.A{getShaders(){const e=super.getShaders();return e.modules.push(b),{...e,vs:y}}initializeState(){super.initializeState();const e=this.getAttributeManager();e.remove(["instanceElevations","instanceFillColors","instanceLineColors","instanceStrokeWidths"]),e.addInstanced({instancePositions:{size:2,type:"float32",accessor:"getBin"},instanceColorValues:{size:1,type:"float32",accessor:"getColorValue"},instanceElevationValues:{size:1,type:"float32",accessor:"getElevationValue"}})}updateState(e){super.updateState(e);const{props:t,oldProps:o}=e,n=this.state.fillModel;if(o.colorRange!==t.colorRange){this.state.colorTexture?.destroy(),this.state.colorTexture=(0,g.cp)(this.context.device,t.colorRange,t.colorScaleType);const e={colorRange:this.state.colorTexture};n.shaderInputs.setProps({hexagon:e})}else o.colorScaleType!==t.colorScaleType&&(0,g.Pu)(this.state.colorTexture,t.colorScaleType)}finalizeState(e){super.finalizeState(e),this.state.colorTexture?.destroy()}draw({uniforms:e}){const{radius:t,hexOriginCommon:o,elevationRange:n,elevationScale:i,extruded:a,coverage:r,colorDomain:s,elevationDomain:l}=this.props,c=this.props.colorCutoff||[-1/0,1/0],g=this.props.elevationCutoff||[-1/0,1/0],u=this.state.fillModel;u.vertexArray.indexBuffer&&u.setIndexBuffer(null),u.setVertexCount(this.state.fillVertexCount);const p={colorDomain:[Math.max(s[0],c[0]),Math.min(s[1],c[1]),Math.max(s[0]-1,c[0]),Math.min(s[1]+1,c[1])],elevationDomain:[Math.max(l[0],g[0]),Math.min(l[1],g[1]),Math.max(l[0]-1,g[0]),Math.min(l[1]+1,g[1])],elevationRange:[n[0]*i,n[1]*i],originCommon:o};u.shaderInputs.setProps({column:{extruded:a,coverage:r,radius:t},hexagon:p}),u.draw(this.context.renderPass)}}P.layerName="HexagonCellLayer";const V=P,S={name:"binOptions",vs:"uniform binOptionsUniforms {\n  vec2 hexOriginCommon;\n  float radiusCommon;\n} binOptions;\n",uniformTypes:{hexOriginCommon:"vec2<f32>",radiusCommon:"f32"}};function A(){}const D={gpuAggregation:!0,colorDomain:null,colorRange:g.QO,getColorValue:{type:"accessor",value:null},getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",lowerPercentile:{type:"number",min:0,max:100,value:0},upperPercentile:{type:"number",min:0,max:100,value:100},colorScaleType:"quantize",onSetColorDomain:A,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:null},getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationScale:{type:"number",min:0,value:1},elevationLowerPercentile:{type:"number",min:0,max:100,value:0},elevationUpperPercentile:{type:"number",min:0,max:100,value:100},elevationScaleType:"linear",onSetElevationDomain:A,radius:{type:"number",min:1,value:1e3},coverage:{type:"number",min:0,max:1,value:1},getPosition:{type:"accessor",value:e=>e.position},hexagonAggregator:{type:"function",optional:!0,value:null},extruded:!1,material:!0};class T extends c.A{getAggregatorType(){const{gpuAggregation:e,hexagonAggregator:t,getColorValue:o,getElevationValue:i}=this.props;return e&&(t||o||i)?(n.A.warn("Features not supported by GPU aggregation, falling back to CPU")(),"cpu"):e&&s.V.isSupported(this.context.device)?"gpu":"cpu"}createAggregator(e){if("cpu"===e){const{hexagonAggregator:e,radius:t}=this.props;return new l.M({dimensions:2,getBin:{sources:["positions"],getValue:({positions:o},n,i)=>{if(e)return e(o,t);const a=this.state.aggregatorViewport.projectPosition(o),{radiusCommon:r,hexOriginCommon:s}=i;return C([a[0]-s[0],a[1]-s[1]],r)}},getValue:[{sources:["colorWeights"],getValue:({colorWeights:e})=>e},{sources:["elevationWeights"],getValue:({elevationWeights:e})=>e}]})}return new s.V(this.context.device,{dimensions:2,channelCount:2,bufferLayout:this.getAttributeManager().getBufferLayouts({isInstanced:!1}),...super.getShaders({modules:[i.A,S],vs:`\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float colorWeights;\n  in float elevationWeights;\n  \n  ${f}\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    binId = pointToHexbin(positionCommon.xy, binOptions.radiusCommon);\n  }\n  void getValue(out vec2 value) {\n    value = vec2(colorWeights, elevationWeights);\n  }\n  `})})}initializeState(){super.initializeState(),this.getAttributeManager().add({positions:{size:3,accessor:"getPosition",type:"float64",fp64:this.use64bitPositions()},colorWeights:{size:1,accessor:"getColorWeight"},elevationWeights:{size:1,accessor:"getElevationWeight"}})}updateState(e){const t=super.updateState(e),{props:o,oldProps:n,changeFlags:i}=e,{aggregator:r}=this.state;if(!i.dataChanged&&this.state.dataAsArray||!o.getColorValue&&!o.getElevationValue||(this.state.dataAsArray=Array.from((0,a.X)(o.data).iterable)),t||i.dataChanged||o.radius!==n.radius||o.getColorValue!==n.getColorValue||o.getElevationValue!==n.getElevationValue||o.colorAggregation!==n.colorAggregation||o.elevationAggregation!==n.elevationAggregation){this._updateBinOptions();const{radiusCommon:e,hexOriginCommon:t,binIdRange:n,dataAsArray:i}=this.state;if(r.setProps({binIdRange:n,pointCount:this.getNumInstances(),operations:[o.colorAggregation,o.elevationAggregation],binOptions:{radiusCommon:e,hexOriginCommon:t},onUpdate:this._onAggregationUpdate.bind(this)}),i){const{getColorValue:e,getElevationValue:t}=this.props;r.setProps({customOperations:[e&&(t=>e(t.map((e=>i[e])),{indices:t,data:o.data})),t&&(e=>t(e.map((e=>i[e])),{indices:e,data:o.data}))]})}}return i.updateTriggersChanged&&i.updateTriggersChanged.getColorValue&&r.setNeedsUpdate(0),i.updateTriggersChanged&&i.updateTriggersChanged.getElevationValue&&r.setNeedsUpdate(1),t}_updateBinOptions(){const e=this.getBounds();let t=1,o=[0,0],n=[[0,1],[0,1]],i=this.context.viewport;if(e&&Number.isFinite(e[0][0])){let a=[(e[0][0]+e[1][0])/2,(e[0][1]+e[1][1])/2];const{radius:s}=this.props,{unitsPerMeter:l}=i.getDistanceScales(a);t=l[0]*s;const c=C(i.projectFlat(a),t);a=i.unprojectFlat(x(c,t));const g=i.constructor;i=i.isGeospatial?new g({longitude:a[0],latitude:a[1],zoom:12}):new r.A({position:[a[0],a[1],0],zoom:12}),o=[Math.fround(i.center[0]),Math.fround(i.center[1])],n=(0,p.O)({dataBounds:e,getBinId:e=>{const n=i.projectFlat(e);return n[0]-=o[0],n[1]-=o[1],C(n,t)},padding:1})}this.setState({radiusCommon:t,hexOriginCommon:o,binIdRange:n,aggregatorViewport:i})}draw(e){e.shaderModuleProps.project&&(e.shaderModuleProps.project.viewport=this.state.aggregatorViewport),super.draw(e)}_onAggregationUpdate({channel:e}){const t=this.getCurrentLayer().props,{aggregator:o}=this.state;if(0===e){const e=o.getResult(0);this.setState({colors:new u.bg(e,o.binCount)}),t.onSetColorDomain(o.getResultDomain(0))}else if(1===e){const e=o.getResult(1);this.setState({elevations:new u.bg(e,o.binCount)}),t.onSetElevationDomain(o.getResultDomain(1))}}onAttributeChange(e){const{aggregator:t}=this.state;switch(e){case"positions":t.setNeedsUpdate(),this._updateBinOptions();const{radiusCommon:e,hexOriginCommon:o,binIdRange:n}=this.state;t.setProps({binIdRange:n,binOptions:{radiusCommon:e,hexOriginCommon:o}});break;case"colorWeights":t.setNeedsUpdate(0);break;case"elevationWeights":t.setNeedsUpdate(1)}}renderLayers(){const{aggregator:e,radiusCommon:t,hexOriginCommon:o}=this.state,{elevationScale:n,colorRange:i,elevationRange:a,extruded:r,coverage:s,material:l,transitions:c,colorScaleType:g,lowerPercentile:u,upperPercentile:p,colorDomain:d,elevationScaleType:m,elevationLowerPercentile:v,elevationUpperPercentile:C,elevationDomain:f}=this.props,x=this.getSubLayerClass("cells",V),y=e.getBins(),b=this.state.colors?.update({scaleType:g,lowerPercentile:u,upperPercentile:p}),P=this.state.elevations?.update({scaleType:m,lowerPercentile:v,upperPercentile:C});return b&&P?new x(this.getSubLayerProps({id:"cells"}),{data:{length:e.binCount,attributes:{getBin:y,getColorValue:b.attribute,getElevationValue:P.attribute}},dataComparator:(e,t)=>e.length===t.length,updateTriggers:{getBin:[y],getColorValue:[b.attribute],getElevationValue:[P.attribute]},diskResolution:6,vertices:h,radius:t,hexOriginCommon:o,elevationScale:n,colorRange:i,colorScaleType:g,elevationRange:a,extruded:r,coverage:s,material:l,colorDomain:b.domain||d||e.getResultDomain(0),elevationDomain:P.domain||f||e.getResultDomain(1),colorCutoff:b.cutoff,elevationCutoff:P.cutoff,transitions:c&&{getFillColor:c.getColorValue||c.getColorWeight,getElevation:c.getElevationValue||c.getElevationWeight},extensions:[]}):null}getPickingInfo(e){const t=e.info,{index:o}=t;if(o>=0){const e=this.state.aggregator.getBin(o);let n;if(e){const t=x(e.id,this.state.radiusCommon),o=this.context.viewport.unprojectFlat(t);n={col:e.id[0],row:e.id[1],position:o,colorValue:e.value[0],elevationValue:e.value[1],count:e.count},e.pointIndices&&(n.pointIndices=e.pointIndices,n.points=Array.isArray(this.props.data)?e.pointIndices.map((e=>this.props.data[e])):[])}t.object=n}return t}}T.layerName="HexagonLayer",T.defaultProps=D;const R=T}}]);