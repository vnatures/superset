"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[3596],{13596:(e,t,o)=>{o.d(t,{A:()=>E});var n=o(18277),i=o(82101),a=o(81729),r=o(35775),l=o(1334),s=o(48928),c=o(12965),g=o(83102),u=o(4359),p=o(34460),m=o(10951),d=o(83391),v=o(48910);class h extends d.V{constructor(e={}){const{id:t=(0,v.L)("cube-geometry"),indices:o=!0}=e;super(o?{...e,id:t,topology:"triangle-list",indices:{size:1,value:C},attributes:{...x,...e.attributes}}:{...e,id:t,topology:"triangle-list",indices:void 0,attributes:{...A,...e.attributes}})}}const C=new Uint16Array([0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]),y=new Float32Array([-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1]),f=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0]),S=new Float32Array([0,0,1,0,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,0,1,1,0,1,0,0,0,0,1,0,1,1,0,1]),b=new Float32Array([1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,-1,-1,1,1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,1,1,-1,1,1,-1,-1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,-1]),z=new Float32Array([1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,1,0,0]),P=new Float32Array([1,0,1,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,1,0,0,1,0,1,0,1]),x={POSITION:{size:3,value:y},NORMAL:{size:3,value:f},TEXCOORD_0:{size:2,value:S}},A={POSITION:{size:3,value:b},TEXCOORD_0:{size:2,value:z},COLOR_0:{size:3,value:P}},V={name:"grid",vs:"uniform gridUniforms {\n  vec4 colorDomain;\n  vec4 elevationDomain;\n  vec2 elevationRange;\n  vec2 originCommon;\n  vec2 sizeCommon;\n} grid;\n",uniformTypes:{colorDomain:"vec4<f32>",elevationDomain:"vec4<f32>",elevationRange:"vec2<f32>",originCommon:"vec2<f32>",sizeCommon:"vec2<f32>"}};class w extends m.A{getShaders(){const e=super.getShaders();return e.modules.push(V),{...e,vs:"#version 300 es\n#define SHADER_NAME grid-cell-layer-vertex-shader\nin vec3 positions;\nin vec3 normals;\nin vec2 instancePositions;\nin float instanceElevationValues;\nin float instanceColorValues;\nin vec3 instancePickingColors;\nuniform sampler2D colorRange;\nout vec4 vColor;\nfloat interp(float value, vec2 domain, vec2 range) {\nfloat r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);\nreturn mix(range.x, range.y, r);\n}\nvec4 interp(float value, vec2 domain, sampler2D range) {\nfloat r = (value - domain.x) / (domain.y - domain.x);\nreturn texture(range, vec2(r, 0.5));\n}\nvoid main(void) {\ngeometry.pickingColor = instancePickingColors;\nif (isnan(instanceColorValues) ||\ninstanceColorValues < grid.colorDomain.z ||\ninstanceColorValues > grid.colorDomain.w ||\ninstanceElevationValues < grid.elevationDomain.z ||\ninstanceElevationValues > grid.elevationDomain.w\n) {\ngl_Position = vec4(0.);\nreturn;\n}\nvec2 commonPosition = (instancePositions + (positions.xy + 1.0) / 2.0 * column.coverage) * grid.sizeCommon + grid.originCommon - project.commonOrigin.xy;\ngeometry.position = vec4(commonPosition, 0.0, 1.0);\ngeometry.normal = project_normal(normals);\nfloat elevation = 0.0;\nif (column.extruded) {\nelevation = interp(instanceElevationValues, grid.elevationDomain.xy, grid.elevationRange);\nelevation = project_size(elevation);\ngeometry.position.z = (positions.z + 1.0) / 2.0 * elevation;\n}\ngl_Position = project_common_position_to_clipspace(geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvColor = interp(instanceColorValues, grid.colorDomain.xy, colorRange);\nvColor.a *= layer.opacity;\nif (column.extruded) {\nvColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\n}\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n"}}initializeState(){super.initializeState();const e=this.getAttributeManager();e.remove(["instanceElevations","instanceFillColors","instanceLineColors","instanceStrokeWidths"]),e.addInstanced({instancePositions:{size:2,type:"float32",accessor:"getBin"},instanceColorValues:{size:1,type:"float32",accessor:"getColorValue"},instanceElevationValues:{size:1,type:"float32",accessor:"getElevationValue"}})}updateState(e){super.updateState(e);const{props:t,oldProps:o}=e,n=this.state.fillModel;if(o.colorRange!==t.colorRange){this.state.colorTexture?.destroy(),this.state.colorTexture=(0,g.cp)(this.context.device,t.colorRange,t.colorScaleType);const e={colorRange:this.state.colorTexture};n.shaderInputs.setProps({grid:e})}else o.colorScaleType!==t.colorScaleType&&(0,g.Pu)(this.state.colorTexture,t.colorScaleType)}finalizeState(e){super.finalizeState(e),this.state.colorTexture?.destroy()}_updateGeometry(){const e=new h;this.state.fillModel.setGeometry(e)}draw({uniforms:e}){const{cellOriginCommon:t,cellSizeCommon:o,elevationRange:n,elevationScale:i,extruded:a,coverage:r,colorDomain:l,elevationDomain:s}=this.props,c=this.props.colorCutoff||[-1/0,1/0],g=this.props.elevationCutoff||[-1/0,1/0],u=this.state.fillModel,p={colorDomain:[Math.max(l[0],c[0]),Math.min(l[1],c[1]),Math.max(l[0]-1,c[0]),Math.min(l[1]+1,c[1])],elevationDomain:[Math.max(s[0],g[0]),Math.min(s[1],g[1]),Math.max(s[0]-1,g[0]),Math.min(s[1]+1,g[1])],elevationRange:[n[0]*i,n[1]*i],originCommon:t,sizeCommon:o};u.shaderInputs.setProps({column:{extruded:a,coverage:r},grid:p}),u.draw(this.context.renderPass)}}w.layerName="GridCellLayer";const O={name:"binOptions",vs:"uniform binOptionsUniforms {\n  vec2 cellOriginCommon;\n  vec2 cellSizeCommon;\n} binOptions;\n",uniformTypes:{cellOriginCommon:"vec2<f32>",cellSizeCommon:"vec2<f32>"}};function D(){}const R={gpuAggregation:!0,colorDomain:null,colorRange:g.QO,getColorValue:{type:"accessor",value:null},getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",lowerPercentile:{type:"number",min:0,max:100,value:0},upperPercentile:{type:"number",min:0,max:100,value:100},colorScaleType:"quantize",onSetColorDomain:D,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:null},getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationScale:{type:"number",min:0,value:1},elevationLowerPercentile:{type:"number",min:0,max:100,value:0},elevationUpperPercentile:{type:"number",min:0,max:100,value:100},elevationScaleType:"linear",onSetElevationDomain:D,cellSize:{type:"number",min:0,value:1e3},coverage:{type:"number",min:0,max:1,value:1},getPosition:{type:"accessor",value:e=>e.position},gridAggregator:{type:"function",optional:!0,value:null},extruded:!1,material:!0};class T extends c.A{getAggregatorType(){const{gpuAggregation:e,gridAggregator:t,getColorValue:o,getElevationValue:i}=this.props;return e&&(t||o||i)?(n.A.warn("Features not supported by GPU aggregation, falling back to CPU")(),"cpu"):e&&l.V.isSupported(this.context.device)?"gpu":"cpu"}createAggregator(e){if("cpu"===e){const{gridAggregator:e,cellSize:t}=this.props;return new s.M({dimensions:2,getBin:{sources:["positions"],getValue:({positions:o},n,i)=>{if(e)return e(o,t);const a=this.state.aggregatorViewport.projectPosition(o),{cellSizeCommon:r,cellOriginCommon:l}=i;return[Math.floor((a[0]-l[0])/r[0]),Math.floor((a[1]-l[1])/r[1])]}},getValue:[{sources:["colorWeights"],getValue:({colorWeights:e})=>e},{sources:["elevationWeights"],getValue:({elevationWeights:e})=>e}]})}return new l.V(this.context.device,{dimensions:2,channelCount:2,bufferLayout:this.getAttributeManager().getBufferLayouts({isInstanced:!1}),...super.getShaders({modules:[i.A,O],vs:"\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float colorWeights;\n  in float elevationWeights;\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out vec2 value) {\n    value = vec2(colorWeights, elevationWeights);\n  }\n  "})})}initializeState(){super.initializeState(),this.getAttributeManager().add({positions:{size:3,accessor:"getPosition",type:"float64",fp64:this.use64bitPositions()},colorWeights:{size:1,accessor:"getColorWeight"},elevationWeights:{size:1,accessor:"getElevationWeight"}})}updateState(e){const t=super.updateState(e),{props:o,oldProps:n,changeFlags:i}=e,{aggregator:r}=this.state;if(!i.dataChanged&&this.state.dataAsArray||!o.getColorValue&&!o.getElevationValue||(this.state.dataAsArray=Array.from((0,a.X)(o.data).iterable)),t||i.dataChanged||o.cellSize!==n.cellSize||o.getColorValue!==n.getColorValue||o.getElevationValue!==n.getElevationValue||o.colorAggregation!==n.colorAggregation||o.elevationAggregation!==n.elevationAggregation){this._updateBinOptions();const{cellSizeCommon:e,cellOriginCommon:t,binIdRange:n,dataAsArray:i}=this.state;if(r.setProps({binIdRange:n,pointCount:this.getNumInstances(),operations:[o.colorAggregation,o.elevationAggregation],binOptions:{cellSizeCommon:e,cellOriginCommon:t},onUpdate:this._onAggregationUpdate.bind(this)}),i){const{getColorValue:e,getElevationValue:t}=this.props;r.setProps({customOperations:[e&&(t=>e(t.map((e=>i[e])),{indices:t,data:o.data})),t&&(e=>t(e.map((e=>i[e])),{indices:e,data:o.data}))]})}}return i.updateTriggersChanged&&i.updateTriggersChanged.getColorValue&&r.setNeedsUpdate(0),i.updateTriggersChanged&&i.updateTriggersChanged.getElevationValue&&r.setNeedsUpdate(1),t}_updateBinOptions(){const e=this.getBounds(),t=[1,1];let o=[0,0],n=[[0,1],[0,1]],i=this.context.viewport;if(e&&Number.isFinite(e[0][0])){let a=[(e[0][0]+e[1][0])/2,(e[0][1]+e[1][1])/2];const{cellSize:l}=this.props,{unitsPerMeter:s}=i.getDistanceScales(a);t[0]=s[0]*l,t[1]=s[1]*l;const c=i.projectFlat(a);o=[Math.floor(c[0]/t[0])*t[0],Math.floor(c[1]/t[1])*t[1]],a=i.unprojectFlat(o);const g=i.constructor;i=i.isGeospatial?new g({longitude:a[0],latitude:a[1],zoom:12}):new r.A({position:[a[0],a[1],0],zoom:12}),o=[Math.fround(i.center[0]),Math.fround(i.center[1])],n=(0,p.O)({dataBounds:e,getBinId:e=>{const n=i.projectFlat(e);return[Math.floor((n[0]-o[0])/t[0]),Math.floor((n[1]-o[1])/t[1])]}})}this.setState({cellSizeCommon:t,cellOriginCommon:o,binIdRange:n,aggregatorViewport:i})}draw(e){e.shaderModuleProps.project&&(e.shaderModuleProps.project.viewport=this.state.aggregatorViewport),super.draw(e)}_onAggregationUpdate({channel:e}){const t=this.getCurrentLayer().props,{aggregator:o}=this.state;if(0===e){const e=o.getResult(0);this.setState({colors:new u.bg(e,o.binCount)}),t.onSetColorDomain(o.getResultDomain(0))}else if(1===e){const e=o.getResult(1);this.setState({elevations:new u.bg(e,o.binCount)}),t.onSetElevationDomain(o.getResultDomain(1))}}onAttributeChange(e){const{aggregator:t}=this.state;switch(e){case"positions":t.setNeedsUpdate(),this._updateBinOptions();const{cellSizeCommon:e,cellOriginCommon:o,binIdRange:n}=this.state;t.setProps({binIdRange:n,binOptions:{cellSizeCommon:e,cellOriginCommon:o}});break;case"colorWeights":t.setNeedsUpdate(0);break;case"elevationWeights":t.setNeedsUpdate(1)}}renderLayers(){const{aggregator:e,cellOriginCommon:t,cellSizeCommon:o}=this.state,{elevationScale:n,colorRange:i,elevationRange:a,extruded:r,coverage:l,material:s,transitions:c,colorScaleType:g,lowerPercentile:u,upperPercentile:p,colorDomain:m,elevationScaleType:d,elevationLowerPercentile:v,elevationUpperPercentile:h,elevationDomain:C}=this.props,y=this.getSubLayerClass("cells",w),f=e.getBins(),S=this.state.colors?.update({scaleType:g,lowerPercentile:u,upperPercentile:p}),b=this.state.elevations?.update({scaleType:d,lowerPercentile:v,upperPercentile:h});return S&&b?new y(this.getSubLayerProps({id:"cells"}),{data:{length:e.binCount,attributes:{getBin:f,getColorValue:S.attribute,getElevationValue:b.attribute}},dataComparator:(e,t)=>e.length===t.length,updateTriggers:{getBin:[f],getColorValue:[S.attribute],getElevationValue:[b.attribute]},cellOriginCommon:t,cellSizeCommon:o,elevationScale:n,colorRange:i,colorScaleType:g,elevationRange:a,extruded:r,coverage:l,material:s,colorDomain:S.domain||m||e.getResultDomain(0),elevationDomain:b.domain||C||e.getResultDomain(1),colorCutoff:S.cutoff,elevationCutoff:b.cutoff,transitions:c&&{getFillColor:c.getColorValue||c.getColorWeight,getElevation:c.getElevationValue||c.getElevationWeight},extensions:[]}):null}getPickingInfo(e){const t=e.info,{index:o}=t;if(o>=0){const e=this.state.aggregator.getBin(o);let n;e&&(n={col:e.id[0],row:e.id[1],colorValue:e.value[0],elevationValue:e.value[1],count:e.count},e.pointIndices&&(n.pointIndices=e.pointIndices,n.points=Array.isArray(this.props.data)?e.pointIndices.map((e=>this.props.data[e])):[])),t.object=n}return t}}T.layerName="GridLayer",T.defaultProps=R;const E=T}}]);