"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[8972],{23197:(i,t,e)=>{e.d(t,{A:()=>o});const n={props:{},uniforms:{},name:"picking",uniformTypes:{isActive:"f32",isAttribute:"f32",isHighlightActive:"f32",useFloatColors:"f32",highlightedObjectColor:"vec3<f32>",highlightColor:"vec4<f32>"},defaultUniforms:{isActive:!1,isAttribute:!1,isHighlightActive:!1,useFloatColors:!0,highlightedObjectColor:[0,0,0],highlightColor:[0,1,1,1]},vs:"uniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nout vec4 picking_vRGBcolor_Avalid;\n\n// Normalize unsigned byte color to 0-1 range\nvec3 picking_normalizeColor(vec3 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\n// Normalize unsigned byte color to 0-1 range\nvec4 picking_normalizeColor(vec4 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\nbool picking_isColorZero(vec3 color) {\n  return dot(color, vec3(1.0)) < 0.00001;\n}\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.00001;\n}\n\n// Check if this vertex is highlighted \nbool isVertexHighlighted(vec3 vertexColor) {\n  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\n  return\n    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\n\n// Set the current picking color\nvoid picking_setPickingColor(vec3 pickingColor) {\n  pickingColor = picking_normalizeColor(pickingColor);\n\n  if (bool(picking.isActive)) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!bool(picking.isAttribute)) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec2 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec3 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n",fs:"uniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (picking.isActive > 0.5) {\n    return color;\n  }\n\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    // Blend in highlight color based on its alpha value\n    float highLightAlpha = picking.highlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highlightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highlightColor);\n}\n",getUniforms:function(i={},t){const e={};if(void 0===i.highlightedObjectColor);else if(null===i.highlightedObjectColor)e.isHighlightActive=!1;else{e.isHighlightActive=!0;const t=i.highlightedObjectColor.slice(0,3);e.highlightedObjectColor=t}if(i.highlightColor){const t=Array.from(i.highlightColor,(i=>i/255));Number.isFinite(t[3])||(t[3]=1),e.highlightColor=t}return void 0!==i.isActive&&(e.isActive=Boolean(i.isActive),e.isAttribute=Boolean(i.isAttribute)),void 0!==i.useFloatColors&&(e.useFloatColors=Boolean(i.useFloatColors)),e}},o={...n,defaultUniforms:{...n.defaultUniforms,useFloatColors:!1},inject:{"vs:DECKGL_FILTER_GL_POSITION":"\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  ","vs:DECKGL_FILTER_COLOR":"\n  picking_setPickingColor(geometry.pickingColor);\n  ","fs:DECKGL_FILTER_COLOR":{order:99,injection:"\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    "}}}},82050:(i,t,e)=>{e.d(t,{rJ:()=>n,wk:()=>p,Eg:()=>m,Mk:()=>u,Iy:()=>_,UD:()=>o});const n={CLOCKWISE:1,COUNTER_CLOCKWISE:-1};function o(i,t,e={}){const n=function(i,t={}){return Math.sign(function(i,t={}){const{start:e=0,end:n=i.length,plane:o="xy"}=t,r=t.size||2;let s=0;const c=l[o[0]],g=l[o[1]];for(let t=e,o=n-r;t<n;t+=r)s+=(i[t+c]-i[o+c])*(i[t+g]+i[o+g]),o=t;return s/2}(i,t))}(i,e);return n!==t&&(function(i,t){const{start:e=0,end:n=i.length,size:o=2}=t,l=(n-e)/o,r=Math.floor(l/2);for(let t=0;t<r;++t){const n=e+t*o,r=e+(l-1-t)*o;for(let t=0;t<o;++t){const e=i[n+t];i[n+t]=i[r+t],i[r+t]=e}}}(i,e),!0)}const l={x:0,y:1,z:2};function r(i,t,e,n,o=[]){let l,r;if(8&e)l=(n[3]-i[1])/(t[1]-i[1]),r=3;else if(4&e)l=(n[1]-i[1])/(t[1]-i[1]),r=1;else if(2&e)l=(n[2]-i[0])/(t[0]-i[0]),r=2;else{if(!(1&e))return null;l=(n[0]-i[0])/(t[0]-i[0]),r=0}for(let e=0;e<i.length;e++)o[e]=(1&r)===e?n[r]:l*(t[e]-i[e])+i[e];return o}function s(i,t){let e=0;return i[0]<t[0]?e|=1:i[0]>t[2]&&(e|=2),i[1]<t[1]?e|=4:i[1]>t[3]&&(e|=8),e}function c(i,t){const e=t.length,n=i.length;if(n>0){let o=!0;for(let l=0;l<e;l++)if(i[n-e+l]!==t[l]){o=!1;break}if(o)return!1}for(let o=0;o<e;o++)i[n+o]=t[o];return!0}function g(i,t){const e=t.length;for(let n=0;n<e;n++)i[n]=t[n]}function h(i,t,e,n,o=[]){const l=n+t*e;for(let t=0;t<e;t++)o[t]=i[l+t];return o}function u(i,t){const{size:e=2,broken:n=!1,gridResolution:o=10,gridOffset:l=[0,0],startIndex:u=0,endIndex:a=i.length}=t||{},f=(a-u)/e;let p=[];const d=[p],b=h(i,0,e,u);let C,A;const _=v(b,o,l,[]),m=[];c(p,b);for(let t=1;t<f;t++){for(C=h(i,t,e,u,C),A=s(C,_);A;){r(b,C,A,_,m);const i=s(m,_);i&&(r(b,m,i,_,m),A=i),c(p,m),g(b,m),k(_,o,A),n&&p.length>e&&(p=[],d.push(p),c(p,b)),A=s(C,_)}c(p,C),g(b,C)}return n?d:d[0]}const a=0,f=1;function p(i,t=null,e){if(!i.length)return[];const{size:n=2,gridResolution:o=10,gridOffset:l=[0,0],edgeTypes:r=!1}=e||{},c=[],g=[{pos:i,types:r?new Array(i.length/n).fill(f):null,holes:t||[]}],h=[[],[]];let u=[];for(;g.length;){const{pos:i,types:t,holes:e}=g.shift();b(i,n,e[0]||i.length,h),u=v(h[0],o,l,u);const a=s(h[1],u);if(a){let o=d(i,t,n,0,e[0]||i.length,u,a);const l={pos:o[0].pos,types:o[0].types,holes:[]},s={pos:o[1].pos,types:o[1].types,holes:[]};g.push(l,s);for(let c=0;c<e.length;c++)o=d(i,t,n,e[c],e[c+1]||i.length,u,a),o[0]&&(l.holes.push(l.pos.length),l.pos=C(l.pos,o[0].pos),r&&(l.types=C(l.types,o[0].types))),o[1]&&(s.holes.push(s.pos.length),s.pos=C(s.pos,o[1].pos),r&&(s.types=C(s.types,o[1].types)))}else{const n={positions:i};r&&(n.edgeTypes=t),e.length&&(n.holeIndices=e),c.push(n)}}return c}function d(i,t,e,n,o,l,s){const u=(o-n)/e,f=[],p=[],d=[],v=[],k=[];let b,C,A;const _=h(i,u-1,e,n);let m=Math.sign(8&s?_[1]-l[3]:_[0]-l[2]),y=t&&t[u-1],O=0,R=0;for(let o=0;o<u;o++)b=h(i,o,e,n,b),C=Math.sign(8&s?b[1]-l[3]:b[0]-l[2]),A=t&&t[n/e+o],C&&m&&m!==C&&(r(_,b,s,l,k),c(f,k)&&d.push(y),c(p,k)&&v.push(y)),C<=0?(c(f,b)&&d.push(A),O-=C):d.length&&(d[d.length-1]=a),C>=0?(c(p,b)&&v.push(A),R+=C):v.length&&(v[v.length-1]=a),g(_,b),m=C,y=A;return[O?{pos:f,types:t&&d}:null,R?{pos:p,types:t&&v}:null]}function v(i,t,e,n){const o=Math.floor((i[0]-e[0])/t)*t+e[0],l=Math.floor((i[1]-e[1])/t)*t+e[1];return n[0]=o,n[1]=l,n[2]=o+t,n[3]=l+t,n}function k(i,t,e){8&e?(i[1]+=t,i[3]+=t):4&e?(i[1]-=t,i[3]-=t):2&e?(i[0]+=t,i[2]+=t):1&e&&(i[0]-=t,i[2]-=t)}function b(i,t,e,n){let o=1/0,l=-1/0,r=1/0,s=-1/0;for(let n=0;n<e;n+=t){const t=i[n],e=i[n+1];o=t<o?t:o,l=t>l?t:l,r=e<r?e:r,s=e>s?e:s}return n[0][0]=o,n[0][1]=r,n[1][0]=l,n[1][1]=s,n}function C(i,t){for(let e=0;e<t.length;e++)i.push(t[e]);return i}const A=85.051129;function _(i,t){const{size:e=2,startIndex:n=0,endIndex:o=i.length,normalize:l=!0}=t||{},r=i.slice(n,o);R(r,e,0,o-n);const s=u(r,{size:e,broken:!0,gridResolution:360,gridOffset:[-180,-180]});if(l)for(const i of s)x(i,e);return s}function m(i,t=null,e){const{size:n=2,normalize:o=!0,edgeTypes:l=!1}=e||{};t=t||[];const r=[],s=[];let c=0,g=0;for(let o=0;o<=t.length;o++){const l=t[o]||i.length,h=g,u=y(i,n,c,l);for(let t=u;t<l;t++)r[g++]=i[t];for(let t=c;t<u;t++)r[g++]=i[t];R(r,n,h,g),O(r,n,h,g,e?.maxLatitude),c=l,s[o]=g}s.pop();const h=p(r,s,{size:n,gridResolution:360,gridOffset:[-180,-180],edgeTypes:l});if(o)for(const i of h)x(i.positions,n);return h}function y(i,t,e,n){let o=-1,l=-1;for(let r=e+1;r<n;r+=t){const t=Math.abs(i[r]);t>o&&(o=t,l=r-1)}return l}function O(i,t,e,n,o=A){const l=i[e],r=i[n-t];if(Math.abs(l-r)>180){const n=h(i,0,t,e);n[0]+=360*Math.round((r-l)/360),c(i,n),n[1]=Math.sign(n[1])*o,c(i,n),n[0]=l,c(i,n)}}function R(i,t,e,n){let o,l=i[0];for(let r=e;r<n;r+=t){o=i[r];const t=o-l;(t>180||t<-180)&&(o-=360*Math.round(t/360)),i[r]=l=o}}function x(i,t){let e;const n=i.length/t;for(let o=0;o<n&&(e=i[o*t],(e+180)%360==0);o++);const o=360*-Math.round(e/360);if(0!==o)for(let e=0;e<n;e++)i[e*t]+=o}},83391:(i,t,e)=>{e.d(t,{V:()=>o});var n=e(48910);class o{id;topology;vertexCount;indices;attributes;userData={};constructor(i){const{attributes:t={},indices:e=null,vertexCount:o=null}=i;this.id=i.id||(0,n.L)("geometry"),this.topology=i.topology,e&&(this.indices=ArrayBuffer.isView(e)?{value:e,size:1}:e),this.attributes={};for(const[i,e]of Object.entries(t)){const t=ArrayBuffer.isView(e)?{value:e}:e;if(!ArrayBuffer.isView(t.value))throw new Error(`${this._print(i)}: must be typed array or object with value as typed array`);if("POSITION"!==i&&"positions"!==i||t.size||(t.size=3),"indices"===i){if(this.indices)throw new Error("Multiple indices detected");this.indices=t}else this.attributes[i]=t}this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this.vertexCount=o||this._calculateVertexCount(this.attributes,this.indices)}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(i){return`Geometry ${this.id} attribute ${i}`}_setAttributes(i,t){return this}_calculateVertexCount(i,t){if(t)return t.value.length;let e=1/0;for(const t of Object.values(i)){const{value:i,size:n,constant:o}=t;!o&&i&&void 0!==n&&n>=1&&(e=Math.min(e,i.length/n))}return e}}}}]);