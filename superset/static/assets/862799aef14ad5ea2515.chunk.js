"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[3137],{4359:(e,t,i)=>{i.d(t,{bg:()=>n});class n{constructor(e,t){this.props={scaleType:"linear",lowerPercentile:0,upperPercentile:100},this.domain=null,this.cutoff=null,this.input=e,this.inputLength=t,this.attribute=e}getScalePercentile(){if(!this._percentile){const e=o(this.input,this.inputLength);this._percentile=function(e,t=100){const i=Array.from(e).filter(Number.isFinite).sort(r);let n=0;const o=Math.max(1,t),l=new Array(o-1);for(;++n<o;)l[n-1]=s(i,n/o);return{attribute:{value:e.map((e=>Number.isFinite(e)?function(e,t){let i=0,n=e.length;for(;i<n;){const o=i+n>>>1;e[o]>t?n=o:i=o+1}return i}(l,e):NaN)),type:"float32",size:1},domain:l}}(e)}return this._percentile}getScaleOrdinal(){if(!this._ordinal){const e=o(this.input,this.inputLength);this._ordinal=function(e){const t=new Set;for(const i of e)Number.isFinite(i)&&t.add(i);const i=Array.from(t).sort(),n=new Map;for(let e=0;e<i.length;e++)n.set(i[e],e);return{attribute:{value:e.map((e=>Number.isFinite(e)?n.get(e):NaN)),type:"float32",size:1},domain:i}}(e)}return this._ordinal}getCutoff({scaleType:e,lowerPercentile:t,upperPercentile:i}){if("quantile"===e)return[t,i-1];if(t>0||i<100){const{domain:n}=this.getScalePercentile();let o=n[Math.floor(t)-1]??-1/0,r=n[Math.floor(i)-1]??1/0;if("ordinal"===e){const{domain:e}=this.getScaleOrdinal();o=e.findIndex((e=>e>=o)),r=e.findIndex((e=>e>r))-1,-2===r&&(r=e.length-1)}return[o,r]}return null}update(e){const t=this.props;if(e.scaleType!==t.scaleType)switch(e.scaleType){case"quantile":{const{attribute:e}=this.getScalePercentile();this.attribute=e,this.domain=[0,99];break}case"ordinal":{const{attribute:e,domain:t}=this.getScaleOrdinal();this.attribute=e,this.domain=[0,t.length-1];break}default:this.attribute=this.input,this.domain=null}return e.scaleType===t.scaleType&&e.lowerPercentile===t.lowerPercentile&&e.upperPercentile===t.upperPercentile||(this.cutoff=this.getCutoff(e)),this.props=e,this}}function o(e,t){const i=(e.stride??4)/4,n=(e.offset??0)/4;let o=e.value;if(!o){const n=e.buffer?.readSyncWebGL(0,4*i*t);n&&(o=new Float32Array(n.buffer),e.value=o)}if(1===i)return o.subarray(0,t);const r=new Float32Array(t);for(let e=0;e<t;e++)r[e]=o[e*i+n];return r}function r(e,t){return e-t}function s(e,t){const i=e.length;if(t<=0||i<2)return e[0];if(t>=1)return e[i-1];const n=(i-1)*t,o=Math.floor(n),r=e[o];return r+(e[o+1]-r)*(n-o)}},10951:(e,t,i)=>{i.d(t,{A:()=>y});var n=i(75077),o=i(82101),r=i(23197),s=i(16704),l=i(27915),a=i(55248);const c={name:"phongMaterial",dependencies:[l.x],source:"struct phongMaterialUniforms {\n  ambient: f32,\n  diffuse: f32,\n  shininess: f32,\n  specularColor: vec3<f32>,\n};\n\n@binding(2) @group(0) var<uniform> material : phongMaterialUniforms;\n\nfn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {\n  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);\n  var lambertian: f32 = dot(light_direction, normal_worldspace);\n  var specular: f32 = 0.0;\n  if (lambertian > 0.0) {\n    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, material.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;\n}\n\nfn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {\n  var lightColor: vec3<f32> = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);\n  lightColor = material.ambient * surfaceColor * lighting.ambientColor;\n\n  if (lighting.lightType == 0) {\n    let pointLight: PointLight  = lighting_getPointLight(0);\n    let light_position_worldspace: vec3<f32> = pointLight.position;\n    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  } else if (lighting.lightType == 1) {\n    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n  /*\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.pointLightCount) {\n      break;\n    }\n    PointLight pointLight = lighting.pointLight[i];\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  }\n\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.directionalLightCount) {\n      break;\n    }\n    DirectionalLight directionalLight = lighting.directionalLight[i];\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  */\n}\n\nfn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{\n  var lightColor = vec3<f32>(0, 0, 0);\n  let surfaceColor = vec3<f32>(0, 0, 0);\n\n  if (lighting.enabled == 0) {\n    let view_direction = normalize(cameraPosition - position_worldspace);\n\n    switch (lighting.lightType) {\n      case 0, default: {\n        let pointLight: PointLight = lighting_getPointLight(0);\n        let light_position_worldspace: vec3<f32> = pointLight.position;\n        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n      }\n      case 1: {\n        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n      }\n    }\n  }\n  return lightColor;\n}\n",vs:a.X,fs:a.l,defines:{LIGHTING_FRAGMENT:1},uniformTypes:{ambient:"f32",diffuse:"f32",shininess:"f32",specularColor:"vec3<f32>"},defaultUniforms:{ambient:.35,diffuse:.6,shininess:32,specularColor:[.15,.15,.15]},getUniforms(e){const t={...e};return t.specularColor&&(t.specularColor=t.specularColor.map((e=>e/255))),{...c.defaultUniforms,...t}}};var d=i(22986),f=i(77117),g=i(18277),h=i(83391),u=i(82050);class p extends h.V{constructor(e){const{indices:t,attributes:i}=function(e){const{radius:t,height:i=1,nradial:n=10}=e;let{vertices:o}=e;o&&(g.A.assert(o.length>=n),o=o.flatMap((e=>[e[0],e[1]])),(0,u.UD)(o,u.rJ.COUNTER_CLOCKWISE));const r=i>0,s=n+1,l=r?3*s+1:n,a=2*Math.PI/n,c=new Uint16Array(r?3*n*2:0),d=new Float32Array(3*l),f=new Float32Array(3*l);let h=0;if(r){for(let e=0;e<s;e++){const r=e*a,s=e%n,l=Math.sin(r),c=Math.cos(r);for(let e=0;e<2;e++)d[h+0]=o?o[2*s]:c*t,d[h+1]=o?o[2*s+1]:l*t,d[h+2]=(.5-e)*i,f[h+0]=o?o[2*s]:c,f[h+1]=o?o[2*s+1]:l,h+=3}d[h+0]=d[h-3],d[h+1]=d[h-2],d[h+2]=d[h-1],h+=3}for(let e=r?0:1;e<s;e++){const r=Math.floor(e/2)*Math.sign(.5-e%2),s=r*a,l=(r+n)%n,c=Math.sin(s),g=Math.cos(s);d[h+0]=o?o[2*l]:g*t,d[h+1]=o?o[2*l+1]:c*t,d[h+2]=i/2,f[h+2]=1,h+=3}if(r){let e=0;for(let t=0;t<n;t++)c[e++]=2*t+0,c[e++]=2*t+2,c[e++]=2*t+0,c[e++]=2*t+1,c[e++]=2*t+1,c[e++]=2*t+3}return{indices:c,attributes:{POSITION:{size:3,value:d},NORMAL:{size:3,value:f}}}}(e);super({...e,indices:t,attributes:i})}}const m="uniform columnUniforms {\n  float radius;\n  float angle;\n  vec2 offset;\n  bool extruded;\n  bool stroked;\n  bool isStroke;\n  float coverage;\n  float elevationScale;\n  float edgeDistance;\n  float widthScale;\n  float widthMinPixels;\n  float widthMaxPixels;\n  highp int radiusUnits;\n  highp int widthUnits;\n} column;\n",v={name:"column",vs:m,fs:m,uniformTypes:{radius:"f32",angle:"f32",offset:"vec2<f32>",extruded:"f32",stroked:"f32",isStroke:"f32",coverage:"f32",elevationScale:"f32",edgeDistance:"f32",widthScale:"f32",widthMinPixels:"f32",widthMaxPixels:"f32",radiusUnits:"i32",widthUnits:"i32"}},_=[0,0,0,255],C={diskResolution:{type:"number",min:4,value:20},vertices:null,radius:{type:"number",min:0,value:1e3},angle:{type:"number",value:0},offset:{type:"array",value:[0,0]},coverage:{type:"number",min:0,max:1,value:1},elevationScale:{type:"number",min:0,value:1},radiusUnits:"meters",lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,extruded:!0,wireframe:!1,filled:!0,stroked:!1,flatShading:!1,getPosition:{type:"accessor",value:e=>e.position},getFillColor:{type:"accessor",value:_},getLineColor:{type:"accessor",value:_},getLineWidth:{type:"accessor",value:1},getElevation:{type:"accessor",value:1e3},material:!0,getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class w extends n.A{getShaders(){const e={},{flatShading:t}=this.props;return t&&(e.FLAT_SHADING=1),super.getShaders({vs:"#version 300 es\n#define SHADER_NAME column-layer-vertex-shader\nin vec3 positions;\nin vec3 normals;\nin vec3 instancePositions;\nin float instanceElevations;\nin vec3 instancePositions64Low;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin float instanceStrokeWidths;\nin vec3 instancePickingColors;\nout vec4 vColor;\n#ifdef FLAT_SHADING\nout vec3 cameraPosition;\nout vec4 position_commonspace;\n#endif\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\nvec4 color = column.isStroke ? instanceLineColors : instanceFillColors;\nmat2 rotationMatrix = mat2(cos(column.angle), sin(column.angle), -sin(column.angle), cos(column.angle));\nfloat elevation = 0.0;\nfloat strokeOffsetRatio = 1.0;\nif (column.extruded) {\nelevation = instanceElevations * (positions.z + 1.0) / 2.0 * column.elevationScale;\n} else if (column.stroked) {\nfloat widthPixels = clamp(\nproject_size_to_pixel(instanceStrokeWidths * column.widthScale, column.widthUnits),\ncolumn.widthMinPixels, column.widthMaxPixels) / 2.0;\nfloat halfOffset = project_pixel_size(widthPixels) / project_size(column.edgeDistance * column.coverage * column.radius);\nif (column.isStroke) {\nstrokeOffsetRatio -= sign(positions.z) * halfOffset;\n} else {\nstrokeOffsetRatio -= halfOffset;\n}\n}\nfloat shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);\nfloat dotRadius = column.radius * column.coverage * shouldRender;\ngeometry.pickingColor = instancePickingColors;\nvec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);\nvec3 centroidPosition64Low = instancePositions64Low;\nvec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + column.offset) * dotRadius;\nif (column.radiusUnits == UNIT_METERS) {\noffset = project_size(offset);\n}\nvec3 pos = vec3(offset, 0.);\nDECKGL_FILTER_SIZE(pos, geometry);\ngl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\ngeometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nif (column.extruded && !column.isStroke) {\n#ifdef FLAT_SHADING\ncameraPosition = project.cameraPosition;\nposition_commonspace = geometry.position;\nvColor = vec4(color.rgb, color.a * layer.opacity);\n#else\nvec3 lightColor = lighting_getLightColor(color.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\nvColor = vec4(lightColor, color.a * layer.opacity);\n#endif\n} else {\nvColor = vec4(color.rgb, color.a * layer.opacity);\n}\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME column-layer-fragment-shader\nprecision highp float;\nout vec4 fragColor;\nin vec4 vColor;\n#ifdef FLAT_SHADING\nin vec3 cameraPosition;\nin vec4 position_commonspace;\n#endif\nvoid main(void) {\nfragColor = vColor;\ngeometry.uv = vec2(0.);\n#ifdef FLAT_SHADING\nif (column.extruded && !column.isStroke && !bool(picking.isActive)) {\nvec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\nfragColor.rgb = lighting_getLightColor(vColor.rgb, cameraPosition, position_commonspace.xyz, normal);\n}\n#endif\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",defines:e,modules:[o.A,t?c:d.J,r.A,v]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceElevations:{size:1,transition:!0,accessor:"getElevation"},instanceFillColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getFillColor",defaultValue:_},instanceLineColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getLineColor",defaultValue:_},instanceStrokeWidths:{size:1,accessor:"getLineWidth",transition:!0}})}updateState(e){super.updateState(e);const{props:t,oldProps:i,changeFlags:n}=e,o=n.extensionsChanged||t.flatShading!==i.flatShading;o&&(this.state.models?.forEach((e=>e.destroy())),this.setState(this._getModels()),this.getAttributeManager().invalidateAll());const r=this.getNumInstances();this.state.fillModel.setInstanceCount(r),this.state.wireframeModel.setInstanceCount(r),(o||t.diskResolution!==i.diskResolution||t.vertices!==i.vertices||(t.extruded||t.stroked)!==(i.extruded||i.stroked))&&this._updateGeometry(t)}getGeometry(e,t,i){const n=new p({radius:1,height:i?2:0,vertices:t,nradial:e});let o=0;if(t)for(let i=0;i<e;i++){const n=t[i];o+=Math.sqrt(n[0]*n[0]+n[1]*n[1])/e}else o=1;return this.setState({edgeDistance:Math.cos(Math.PI/e)*o}),n}_getModels(){const e=this.getShaders(),t=this.getAttributeManager().getBufferLayouts(),i=new f.K(this.context.device,{...e,id:`${this.props.id}-fill`,bufferLayout:t,isInstanced:!0}),n=new f.K(this.context.device,{...e,id:`${this.props.id}-wireframe`,bufferLayout:t,isInstanced:!0});return{fillModel:i,wireframeModel:n,models:[n,i]}}_updateGeometry({diskResolution:e,vertices:t,extruded:i,stroked:n}){const o=this.getGeometry(e,t,i||n);this.setState({fillVertexCount:o.attributes.POSITION.value.length/3});const r=this.state.fillModel,s=this.state.wireframeModel;r.setGeometry(o),r.setTopology("triangle-strip"),r.setIndexBuffer(null),s.setGeometry(o),s.setTopology("line-list")}draw({uniforms:e}){const{lineWidthUnits:t,lineWidthScale:i,lineWidthMinPixels:n,lineWidthMaxPixels:o,radiusUnits:r,elevationScale:l,extruded:a,filled:c,stroked:d,wireframe:f,offset:g,coverage:h,radius:u,angle:p}=this.props,m=this.state.fillModel,v=this.state.wireframeModel,{fillVertexCount:_,edgeDistance:C}=this.state,w={radius:u,angle:p/180*Math.PI,offset:g,extruded:a,stroked:d,coverage:h,elevationScale:l,edgeDistance:C,radiusUnits:s.p5[r],widthUnits:s.p5[t],widthScale:i,widthMinPixels:n,widthMaxPixels:o};a&&f&&(v.shaderInputs.setProps({column:{...w,isStroke:!0}}),v.draw(this.context.renderPass)),c&&(m.setVertexCount(_),m.shaderInputs.setProps({column:{...w,isStroke:!1}}),m.draw(this.context.renderPass)),!a&&d&&(m.setVertexCount(2*_/3),m.shaderInputs.setProps({column:{...w,isStroke:!0}}),m.draw(this.context.renderPass))}}w.layerName="ColumnLayer",w.defaultProps=C;const y=w},34460:(e,t,i)=>{function n({dataBounds:e,getBinId:t,padding:i=0}){const n=[e[0],e[1],[e[0][0],e[1][1]],[e[1][0],e[0][1]]].map((e=>t(e))),o=Math.min(...n.map((e=>e[0])))-i,r=Math.min(...n.map((e=>e[1])))-i;return[[o,Math.max(...n.map((e=>e[0])))+i+1],[r,Math.max(...n.map((e=>e[1])))+i+1]]}i.d(t,{O:()=>n})},83102:(e,t,i)=>{i.d(t,{Pu:()=>s,QO:()=>n,Y5:()=>o,cp:()=>l});const n=[[255,255,178],[254,217,118],[254,178,76],[253,141,60],[240,59,32],[189,0,38]];function o(e,t=!1,i=Float32Array){let n;if(Number.isFinite(e[0]))n=new i(e);else{n=new i(4*e.length);let t=0;for(let i=0;i<e.length;i++){const o=e[i];n[t++]=o[0],n[t++]=o[1],n[t++]=o[2],n[t++]=Number.isFinite(o[3])?o[3]:255}}if(t)for(let e=0;e<n.length;e++)n[e]/=255;return n}const r={linear:"linear",quantile:"nearest",quantize:"nearest",ordinal:"nearest"};function s(e,t){e.setSampler({minFilter:r[t],magFilter:r[t]})}function l(e,t,i="linear"){const n=o(t,!1,Uint8Array);return e.createTexture({format:"rgba8unorm",mipmaps:!1,sampler:{minFilter:r[i],magFilter:r[i],addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"},data:n,width:n.length/4,height:1})}}}]);